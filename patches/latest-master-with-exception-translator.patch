diff --git a/.appveyor.yml b/.appveyor.yml
index 5e283af..80e02f4 100644
--- a/.appveyor.yml
+++ b/.appveyor.yml
@@ -19,8 +19,6 @@ install:
 build_script:
   - echo Running cmake...
   - cd c:\projects\pybind11
-  - cmake -G "%CMAKE_PLATFORM%" -DPYTHON_INCLUDE_DIR:PATH=%PYTHON_DIR%/include -DPYTHON_LIBRARY:FILEPATH=%PYTHON_DIR%/libs/python34.lib -DPYTHON_EXECUTABLE:FILEPATH=%PYTHON_DIR%/python.exe
+  - cmake -G "%CMAKE_PLATFORM%" -DPYTHON_EXECUTABLE:FILEPATH=%PYTHON_DIR%/python.exe
   - set MSBuildLogger="C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll"
-  - set MSBuildOptions=/v:m /p:Configuration=%Configuration% /logger:%MSBuildLogger%
-  - msbuild %MSBuildOptions% pybind11.sln
-  - ctest -C %Configuration%
+  - cmake --build . --config %Configuration% --target check -- /v:m /logger:%MSBuildLogger%
diff --git a/.gitignore b/.gitignore
index a7a4956..1670194 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,7 +4,9 @@ Makefile
 cmake_install.cmake
 .DS_Store
 /example/example.so
+/example/example.cpython*.so
 /example/example.pyd
+/example/example*.dll
 *.sln
 *.sdf
 *.opensdf
diff --git a/.travis.yml b/.travis.yml
index 9a9088f..3f9cb50 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,11 +3,13 @@ sudo: false
 cache:
   directories:
   - $HOME/.cache/pip
+  - ccache
 addons:
   apt:
     sources:
       - ubuntu-toolchain-r-test
       - deadsnakes
+      - kubuntu-backports # cmake 2.8.12
     packages:
       - g++-4.8
       - g++-4.8-multilib
@@ -16,23 +18,24 @@ addons:
       - python3.5-dev
       - python3.5-venv
       - python3.5-dev:i386
+      - cmake
 matrix:
   include:
     - os: linux
       compiler: gcc-4.8
-      script:
+      install:
         - pyvenv-3.5 venv
-        - cmake -DPYBIND11_PYTHON_VERSION=3.5 -DPYTHON_INCLUDE_DIR:PATH=/usr/include/python3.5m -DPYTHON_LIBRARY:FILEPATH=/usr/lib/x86_64-linux-gnu/libpython3.5m.so -DPYTHON_EXECUTABLE:FILEPATH=`pwd`/venv/bin/python3.5 -DCMAKE_CXX_COMPILER=g++-4.8
-        - make -j 2
         - source venv/bin/activate
+        - pip install -U pip wheel
         - pip install numpy
-        - CTEST_OUTPUT_ON_FAILURE=TRUE make test
+      script:
+        - CXX=g++-4.8 cmake -DPYBIND11_PYTHON_VERSION=3.5
+        - CTEST_OUTPUT_ON_FAILURE=TRUE make check -j 2
     - os: osx
       compiler: clang
       script:
         - cmake -DPYBIND11_PYTHON_VERSION=2.7
-        - make -j 2
-        - CTEST_OUTPUT_ON_FAILURE=TRUE make test
+        - CTEST_OUTPUT_ON_FAILURE=TRUE make check -j 2
     #- os: linux
       #compiler: gcc-4.8
       #script:
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 2996e53..7d2c991 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -5,216 +5,166 @@
 # All rights reserved. Use of this source code is governed by a
 # BSD-style license that can be found in the LICENSE file.
 
-cmake_minimum_required(VERSION 2.8)
+cmake_minimum_required(VERSION 2.8.12)
 
 project(pybind11)
 
-option(PYBIND11_INSTALL "Install pybind11 header files?" ON)
+# Check if pybind11 is being used directly or via add_subdirectory
+set(PYBIND11_MASTER_PROJECT OFF)
+if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
+  set(PYBIND11_MASTER_PROJECT ON)
+endif()
+
+option(PYBIND11_INSTALL "Install pybind11 header files?" ${PYBIND11_MASTER_PROJECT})
+option(PYBIND11_TEST    "Build pybind11 test suite?"     ${PYBIND11_MASTER_PROJECT})
 
 # Add a CMake parameter for choosing a desired Python version
 set(PYBIND11_PYTHON_VERSION "" CACHE STRING "Python version to use for compiling the example application")
 
-include(CheckCXXCompilerFlag)
-
-# Set a default build configuration if none is specified. 'MinSizeRel' produces the smallest binaries
-if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
-  message(STATUS "Setting build type to 'MinSizeRel' as none was specified.")
-  set(CMAKE_BUILD_TYPE MinSizeRel CACHE STRING "Choose the type of build." FORCE)
-  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release"
-    "MinSizeRel" "RelWithDebInfo")
-endif()
-string(TOUPPER "${CMAKE_BUILD_TYPE}" U_CMAKE_BUILD_TYPE)
-
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/tools")
 set(Python_ADDITIONAL_VERSIONS 3.4 3.5 3.6 3.7)
-if (NOT ${PYBIND11_PYTHON_VERSION} STREQUAL "")
-  find_package(PythonLibs ${PYBIND11_PYTHON_VERSION} EXACT)
-  if (NOT PythonLibs_FOUND)
-    find_package(PythonLibs ${PYBIND11_PYTHON_VERSION} REQUIRED)
-  endif()
-else()
-  find_package(PythonLibs REQUIRED)
-endif()
-# The above sometimes returns version numbers like "3.4.3+"; the "+" must be removed for the next line to work
-string(REPLACE "+" "" PYTHONLIBS_VERSION_STRING "+${PYTHONLIBS_VERSION_STRING}")
-find_package(PythonInterp ${PYTHONLIBS_VERSION_STRING} EXACT REQUIRED)
+find_package(PythonLibsNew ${PYBIND11_PYTHON_VERSION} REQUIRED)
+
+include(CheckCXXCompilerFlag)
 
-if (CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_CXX_COMPILER_ID MATCHES "GNU" OR CMAKE_CXX_COMPILER_ID MATCHES "Intel")
-  CHECK_CXX_COMPILER_FLAG("-std=c++14" HAS_CPP14_FLAG)
-  CHECK_CXX_COMPILER_FLAG("-std=c++11" HAS_CPP11_FLAG)
+if(NOT MSVC AND NOT PYBIND11_CPP_STANDARD)
+  check_cxx_compiler_flag("-std=c++14" HAS_CPP14_FLAG)
+  check_cxx_compiler_flag("-std=c++11" HAS_CPP11_FLAG)
 
   if (HAS_CPP14_FLAG)
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++14")
+    set(PYBIND11_CPP_STANDARD -std=c++14)
   elseif (HAS_CPP11_FLAG)
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+    set(PYBIND11_CPP_STANDARD -std=c++11)
   else()
     message(FATAL_ERROR "Unsupported compiler -- pybind11 requires C++11 support!")
   endif()
 
-  # Enable link time optimization and set the default symbol
-  # visibility to hidden (very important to obtain small binaries)
-  if (NOT ${U_CMAKE_BUILD_TYPE} MATCHES DEBUG)
-    # Default symbol visibility
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility=hidden")
-
-    # Check for Link Time Optimization support
-    # (GCC/Clang)
-    CHECK_CXX_COMPILER_FLAG("-flto" HAS_LTO_FLAG)
-    if (HAS_LTO_FLAG)
-      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -flto")
-    endif()
-
-    # Intel equivalent to LTO is called IPO
-    if (CMAKE_CXX_COMPILER_ID MATCHES "Intel")
-      CHECK_CXX_COMPILER_FLAG("-ipo" HAS_IPO_FLAG)
-      if (HAS_IPO_FLAG)
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -ipo")
-      endif()
-    endif()
-  endif()
+  set(PYBIND11_CPP_STANDARD ${PYBIND11_CPP_STANDARD} CACHE STRING
+      "C++ standard flag, e.g. -std=c++11 or -std=c++14. Defaults to latest available.")
 endif()
 
-# Compile with compiler warnings turned on
-if(MSVC)
-  if(CMAKE_CXX_FLAGS MATCHES "/W[0-4]")
-    string(REGEX REPLACE "/W[0-4]" "/W4" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
-  else()
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W4")
+# Cache variables so pybind11_add_module can be used in parent projects
+set(PYBIND11_INCLUDE_DIR "${CMAKE_CURRENT_LIST_DIR}/include" CACHE INTERNAL "")
+set(PYTHON_INCLUDE_DIRS ${PYTHON_INCLUDE_DIRS} CACHE INTERNAL "")
+set(PYTHON_LIBRARIES ${PYTHON_LIBRARIES} CACHE INTERNAL "")
+set(PYTHON_MODULE_PREFIX ${PYTHON_MODULE_PREFIX} CACHE INTERNAL "")
+set(PYTHON_MODULE_EXTENSION ${PYTHON_MODULE_EXTENSION} CACHE INTERNAL "")
+
+# Build a Python extension module:
+# pybind11_add_module(<name> source1 [source2 ...])
+#
+function(pybind11_add_module target_name)
+  add_library(${target_name} MODULE ${ARGN})
+  target_include_directories(${target_name} PUBLIC ${PYBIND11_INCLUDE_DIR} ${PYTHON_INCLUDE_DIRS})
+
+  # The prefix and extension are provided by FindPythonLibsNew.cmake
+  set_target_properties(${target_name} PROPERTIES PREFIX "${PYTHON_MODULE_PREFIX}")
+  set_target_properties(${target_name} PROPERTIES SUFFIX "${PYTHON_MODULE_EXTENSION}")
+
+  if(WIN32 OR CYGWIN)
+    # Link against the Python shared library on Windows
+    target_link_libraries(${target_name} PRIVATE ${PYTHON_LIBRARIES})
+  elseif(APPLE)
+    # It's quite common to have multiple copies of the same Python version
+    # installed on one's system. E.g.: one copy from the OS and another copy
+    # that's statically linked into an application like Blender or Maya.
+    # If we link our plugin library against the OS Python here and import it
+    # into Blender or Maya later on, this will cause segfaults when multiple
+    # conflicting Python instances are active at the same time (even when they
+    # are of the same version).
+
+    # Windows is not affected by this issue since it handles DLL imports
+    # differently. The solution for Linux and Mac OS is simple: we just don't
+    # link against the Python library. The resulting shared library will have
+    # missing symbols, but that's perfectly fine -- they will be resolved at
+    # import time.
+
+    target_link_libraries(${target_name} PRIVATE "-undefined dynamic_lookup")
   endif()
-elseif ("${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang" OR "${CMAKE_CXX_COMPILER_ID}" MATCHES "GNU")
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra")
-endif()
 
-# Include path for Python header files
-include_directories(${PYTHON_INCLUDE_DIR})
-
-# Include path for pybind11 header files
-include_directories(include)
-
-set(PYBIND11_HEADERS
-  include/pybind11/attr.h
-  include/pybind11/cast.h
-  include/pybind11/common.h
-  include/pybind11/complex.h
-  include/pybind11/descr.h
-  include/pybind11/functional.h
-  include/pybind11/numpy.h
-  include/pybind11/operators.h
-  include/pybind11/pybind11.h
-  include/pybind11/pytypes.h
-  include/pybind11/stl.h
-  include/pybind11/typeid.h
-)
-
-set(PYBIND11_EXAMPLES
-  example/example1.cpp
-  example/example2.cpp
-  example/example3.cpp
-  example/example4.cpp
-  example/example5.cpp
-  example/example6.cpp
-  example/example7.cpp
-  example/example8.cpp
-  example/example9.cpp
-  example/example10.cpp
-  example/example11.cpp
-  example/example12.cpp
-  example/example13.cpp
-  example/example14.cpp
-  example/example15.cpp
-  example/example16.cpp
-  example/issues.cpp
-)
-
-# Create the binding library
-add_library(example SHARED
-  ${PYBIND11_HEADERS}
-  example/example.cpp
-  ${PYBIND11_EXAMPLES}
-)
-
-# Don't add a 'lib' prefix to the shared library
-set_target_properties(example PROPERTIES PREFIX "")
-
-# Always write the output file directly into the 'example' directory (even on MSVC)
-set(CompilerFlags
-  LIBRARY_OUTPUT_DIRECTORY LIBRARY_OUTPUT_DIRECTORY_RELEASE LIBRARY_OUTPUT_DIRECTORY_DEBUG
-  LIBRARY_OUTPUT_DIRECTORY_MINSIZEREL LIBRARY_OUTPUT_DIRECTORY_RELWITHDEBINFO
-  RUNTIME_OUTPUT_DIRECTORY RUNTIME_OUTPUT_DIRECTORY_RELEASE RUNTIME_OUTPUT_DIRECTORY_DEBUG
-  RUNTIME_OUTPUT_DIRECTORY_MINSIZEREL RUNTIME_OUTPUT_DIRECTORY_RELWITHDEBINFO)
-
-foreach(CompilerFlag ${CompilerFlags})
-  set_target_properties(example PROPERTIES ${CompilerFlag} ${PROJECT_SOURCE_DIR}/example)
-endforeach()
-
-if (WIN32)
-  if (MSVC)
-    # /bigobj is needed for bigger binding projects due to the limit to 64k
-    # addressable sections. /MP enables multithreaded builds (relevant when
-    # there are many files).
-    set_target_properties(example PROPERTIES COMPILE_FLAGS "/MP /bigobj ")
+  if(NOT MSVC)
+    # Make sure C++11/14 are enabled
+    target_compile_options(${target_name} PUBLIC ${PYBIND11_CPP_STANDARD})
 
+    # Enable link time optimization and set the default symbol
+    # visibility to hidden (very important to obtain small binaries)
+    string(TOUPPER "${CMAKE_BUILD_TYPE}" U_CMAKE_BUILD_TYPE)
     if (NOT ${U_CMAKE_BUILD_TYPE} MATCHES DEBUG)
-      # Enforce size-based optimization and link time code generation on MSVC
-      # (~30% smaller binaries in experiments).
-      set_target_properties(example APPEND_STRING PROPERTY COMPILE_FLAGS "/Os /GL ")
-      set_target_properties(example APPEND_STRING PROPERTY LINK_FLAGS "/LTCG ")
-    endif()
-  endif()
+      # Check for Link Time Optimization support (GCC/Clang)
+      check_cxx_compiler_flag("-flto" HAS_LTO_FLAG)
+      if(HAS_LTO_FLAG AND NOT CYGWIN)
+        target_compile_options(${target_name} PRIVATE -flto)
+      endif()
 
-  # .PYD file extension on Windows
-  set_target_properties(example PROPERTIES SUFFIX ".pyd")
-
-  # Link against the Python shared library
-  target_link_libraries(example ${PYTHON_LIBRARY})
-elseif (UNIX)
-  # It's quite common to have multiple copies of the same Python version
-  # installed on one's system. E.g.: one copy from the OS and another copy
-  # that's statically linked into an application like Blender or Maya.
-  # If we link our plugin library against the OS Python here and import it
-  # into Blender or Maya later on, this will cause segfaults when multiple
-  # conflicting Python instances are active at the same time (even when they
-  # are of the same version).
-
-  # Windows is not affected by this issue since it handles DLL imports
-  # differently. The solution for Linux and Mac OS is simple: we just don't
-  # link against the Python library. The resulting shared library will have
-  # missing symbols, but that's perfectly fine -- they will be resolved at
-  # import time.
-
-  # .SO file extension on Linux/Mac OS
-  set_target_properties(example PROPERTIES SUFFIX ".so")
-
-  # Optimize for a small binary size
-  if (NOT ${U_CMAKE_BUILD_TYPE} MATCHES DEBUG)
-    set_target_properties(example PROPERTIES COMPILE_FLAGS "-Os")
-  endif()
+      # Intel equivalent to LTO is called IPO
+      if(CMAKE_CXX_COMPILER_ID MATCHES "Intel")
+        check_cxx_compiler_flag("-ipo" HAS_IPO_FLAG)
+        if(HAS_IPO_FLAG)
+          target_compile_options(${target_name} PRIVATE -ipo)
+        endif()
+      endif()
 
-  # Strip unnecessary sections of the binary on Linux/Mac OS
-  if(APPLE)
-    set_target_properties(example PROPERTIES MACOSX_RPATH ".")
-    set_target_properties(example PROPERTIES LINK_FLAGS "-undefined dynamic_lookup ")
-    if (NOT ${U_CMAKE_BUILD_TYPE} MATCHES DEBUG)
-      add_custom_command(TARGET example POST_BUILD COMMAND strip -u -r ${PROJECT_SOURCE_DIR}/example/example.so)
-    endif()
-  else()
-    if (NOT ${U_CMAKE_BUILD_TYPE} MATCHES DEBUG)
-      add_custom_command(TARGET example POST_BUILD COMMAND strip ${PROJECT_SOURCE_DIR}/example/example.so)
+      # Default symbol visibility
+      target_compile_options(${target_name} PRIVATE "-fvisibility=hidden")
+
+      # Strip unnecessary sections of the binary on Linux/Mac OS
+      if(CMAKE_STRIP)
+        if(APPLE)
+          add_custom_command(TARGET ${target_name} POST_BUILD
+                             COMMAND ${CMAKE_STRIP} -u -r $<TARGET_FILE:${target_name}>)
+        else()
+          add_custom_command(TARGET ${target_name} POST_BUILD
+                             COMMAND ${CMAKE_STRIP} $<TARGET_FILE:${target_name}>)
+        endif()
+      endif()
     endif()
+  elseif(MSVC)
+    # /MP enables multithreaded builds (relevant when there are many files), /bigobj is
+    # needed for bigger binding projects due to the limit to 64k addressable sections
+    target_compile_options(${target_name} PRIVATE /MP /bigobj)
+
+    # Enforce link time code generation on MSVC, except in debug mode
+    target_compile_options(${target_name} PRIVATE $<$<NOT:$<CONFIG:Debug>>:/GL>)
+
+    # Fancy generator expressions don't work with linker flags, for reasons unknown
+    set_property(TARGET ${target_name} APPEND_STRING PROPERTY LINK_FLAGS_RELEASE /LTCG)
+    set_property(TARGET ${target_name} APPEND_STRING PROPERTY LINK_FLAGS_MINSIZEREL /LTCG)
+    set_property(TARGET ${target_name} APPEND_STRING PROPERTY LINK_FLAGS_RELWITHDEBINFO /LTCG)
   endif()
-endif()
+endfunction()
 
-enable_testing()
+# Compile with compiler warnings turned on
+function(pybind11_enable_warnings target_name)
+  if(MSVC)
+    target_compile_options(${target_name} PRIVATE /W4)
+  else()
+    target_compile_options(${target_name} PRIVATE -Wall -Wextra -Wconversion)
+  endif()
+endfunction()
 
-set(RUN_TEST ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/example/run_test.py)
-if (MSVC OR CMAKE_CXX_COMPILER_ID MATCHES "Intel")
-  set(RUN_TEST ${RUN_TEST} --relaxed)
+if (PYBIND11_TEST)
+  enable_testing()
+  add_subdirectory(example)
+  add_custom_target(check COMMAND ${CMAKE_CTEST_COMMAND} -C $<CONFIGURATION> DEPENDS example)
 endif()
 
-foreach(VALUE ${PYBIND11_EXAMPLES})
-  string(REGEX REPLACE "^example/(.+).cpp$" "\\1" EXAMPLE_NAME "${VALUE}")
-  add_test(NAME ${EXAMPLE_NAME} COMMAND ${RUN_TEST} ${EXAMPLE_NAME})
-endforeach()
-
 if (PYBIND11_INSTALL)
-    install(FILES ${PYBIND11_HEADERS} DESTINATION include/pybind11)
+  set(PYBIND11_HEADERS
+    include/pybind11/attr.h
+    include/pybind11/cast.h
+    include/pybind11/common.h
+    include/pybind11/complex.h
+    include/pybind11/descr.h
+    include/pybind11/eigen.h
+    include/pybind11/functional.h
+    include/pybind11/numpy.h
+    include/pybind11/operators.h
+    include/pybind11/pybind11.h
+    include/pybind11/pytypes.h
+    include/pybind11/stl.h
+    include/pybind11/stl_bind.h
+    include/pybind11/typeid.h
+  )
+
+  install(FILES ${PYBIND11_HEADERS} DESTINATION include/pybind11)
 endif()
diff --git a/README.md b/README.md
index 93e30dc..a313c6f 100644
--- a/README.md
+++ b/README.md
@@ -90,6 +90,7 @@ In addition to the core functionality, pybind11 provides some extra goodies:
 2. GCC (any non-ancient version with C++11 support)
 3. Microsoft Visual Studio 2015 or newer
 4. Intel C++ compiler v15 or newer
+5. Cygwin/GCC (tested on 2.5.1)
 
 ## About
 
@@ -99,9 +100,12 @@ Jonas Adler,
 Sylvain Corlay,
 Axel Huebl,
 @hulucc,
+Sergey Lyskov
 Johan Mabille,
-Tomasz Miąsko, and
-Ben Pritchard.
+Tomasz Miąsko,
+Dean Moldovan,
+Ben Pritchard, and
+Boris Schäling.
 
 ### License
 
diff --git a/conda.recipe/bld.bat b/conda.recipe/bld.bat
deleted file mode 100644
index b9cd616..0000000
--- a/conda.recipe/bld.bat
+++ /dev/null
@@ -1,2 +0,0 @@
-"%PYTHON%" setup.py install --single-version-externally-managed --record=record.txt
-if errorlevel 1 exit 1
diff --git a/conda.recipe/build.sh b/conda.recipe/build.sh
deleted file mode 100644
index 175d6f1..0000000
--- a/conda.recipe/build.sh
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/bin/bash
-${PYTHON} setup.py install --single-version-externally-managed --record=record.txt;
-
diff --git a/conda.recipe/meta.yaml b/conda.recipe/meta.yaml
deleted file mode 100644
index fbbb830..0000000
--- a/conda.recipe/meta.yaml
+++ /dev/null
@@ -1,26 +0,0 @@
-package:
-  name: pybind11
-  version: {{ environ.get('GIT_DESCRIBE_TAG', '').replace('v', '') }}
-
-build:
-  number: {{ environ.get('GIT_DESCRIBE_NUMBER', 0) }}
-  {% if environ.get('GIT_DESCRIBE_NUMBER', '0') == '0' %}string: py{{ environ.get('PY_VER').replace('.', '') }}_0
-  {% else %}string: py{{ environ.get('PY_VER').replace('.', '') }}_{{ environ.get('GIT_BUILD_STR', 'GIT_STUB') }}{% endif %}
-
-source:
-  git_url: ../
-
-requirements:
-  build:
-    - python
-
-  run:
-    - python
-
-test:
-  imports:
-    - pybind11
-
-about:
-  home: https://github.com/pybind/pybind11/
-  summary: Seamless operability between C++11 and Python
diff --git a/docs/advanced.rst b/docs/advanced.rst
index 9659709..db1e1c2 100644
--- a/docs/advanced.rst
+++ b/docs/advanced.rst
@@ -157,7 +157,7 @@ trivial to generate binding code for both of these functions.
 
 The following interactive session shows how to call them from Python.
 
-.. code-block:: python
+.. code-block:: pycon
 
     $ python
     >>> import example
@@ -268,8 +268,14 @@ helper class that is defined as follows:
 
 The macro :func:`PYBIND11_OVERLOAD_PURE` should be used for pure virtual
 functions, and :func:`PYBIND11_OVERLOAD` should be used for functions which have
-a default implementation. The binding code also needs a few minor adaptations
-(highlighted):
+a default implementation. 
+
+There are also two alternate macros :func:`PYBIND11_OVERLOAD_PURE_NAME` and
+:func:`PYBIND11_OVERLOAD_NAME` which take a string-valued name argument
+after the *Name of the function* slot. This is useful when the C++ and Python
+versions of the function have different names, e.g. ``operator()`` vs ``__call__``.
+
+The binding code also needs a few minor adaptations (highlighted):
 
 .. code-block:: cpp
     :emphasize-lines: 4,6,7
@@ -277,9 +283,8 @@ a default implementation. The binding code also needs a few minor adaptations
     PYBIND11_PLUGIN(example) {
         py::module m("example", "pybind11 example plugin");
 
-        py::class_<PyAnimal> animal(m, "Animal");
+        py::class_<Animal, std::unique_ptr<Animal>, PyAnimal /* <--- trampoline*/> animal(m, "Animal");
         animal
-            .alias<Animal>()
             .def(py::init<>())
             .def("go", &Animal::go);
 
@@ -291,15 +296,15 @@ a default implementation. The binding code also needs a few minor adaptations
         return m.ptr();
     }
 
-Importantly, the trampoline helper class is used as the template argument to
-:class:`class_`, and a call to :func:`class_::alias` informs the binding
-generator that this is merely an alias for the underlying type ``Animal``.
-Following this, we are able to define a constructor as usual.
+Importantly, pybind11 is made aware of the trampoline trampoline helper class
+by specifying it as the *third* template argument to :class:`class_`. The
+second argument with the unique pointer is simply the default holder type used
+by pybind11. Following this, we are able to define a constructor as usual.
 
 The Python session below shows how to override ``Animal::go`` and invoke it via
 a virtual method call.
 
-.. code-block:: python
+.. code-block:: pycon
 
     >>> from example import *
     >>> d = Dog()
@@ -313,6 +318,8 @@ a virtual method call.
     >>> call_go(c)
     u'meow! meow! meow! '
 
+Please take a look at the :ref:`macro_notes` before using this feature.
+
 .. seealso::
 
     The file :file:`example/example12.cpp` contains a complete example that
@@ -320,6 +327,21 @@ a virtual method call.
     detail.
 
 
+.. _macro_notes:
+
+General notes regarding convenience macros
+==========================================
+
+pybind11 provides a few convenience macros such as
+:func:`PYBIND11_MAKE_OPAQUE` and :func:`PYBIND11_DECLARE_HOLDER_TYPE`, and
+``PYBIND11_OVERLOAD_*``. Since these are "just" macros that are evaluated
+in the preprocessor (which has no concept of types), they *will* get confused
+by commas in a template argument such as ``PYBIND11_OVERLOAD(MyReturnValue<T1,
+T2>, myFunc)``. In this case, the preprocessor assumes that the comma indicates
+the beginnning of the next parameter. Use a ``typedef`` to bind the template to
+another name and use it in the macro to avoid this problem.
+
+
 Global Interpreter Lock (GIL)
 =============================
 
@@ -354,9 +376,8 @@ be realized as follows (important changes highlighted):
     PYBIND11_PLUGIN(example) {
         py::module m("example", "pybind11 example plugin");
 
-        py::class_<PyAnimal> animal(m, "Animal");
+        py::class_<Animal, std::unique_ptr<Animal>, PyAnimal> animal(m, "Animal");
         animal
-            .alias<Animal>()
             .def(py::init<>())
             .def("go", &Animal::go);
 
@@ -515,12 +536,13 @@ specified to indicate dependencies between parameters. There is currently just
 one policy named ``keep_alive<Nurse, Patient>``, which indicates that the
 argument with index ``Patient`` should be kept alive at least until the
 argument with index ``Nurse`` is freed by the garbage collector; argument
-indices start at one, while zero refers to the return value. Arbitrarily many
-call policies can be specified.
+indices start at one, while zero refers to the return value. For methods, index
+one refers to the implicit ``this`` pointer, while regular arguments begin at
+index two. Arbitrarily many call policies can be specified.
 
-For instance, binding code for a a list append operation that ties the lifetime
-of the newly added element to the underlying container might be declared as
-follows:
+Consider the following example: the binding code for a list append operation
+that ties the lifetime of the newly added element to the underlying container
+might be declared as follows:
 
 .. code-block:: cpp
 
@@ -542,7 +564,7 @@ Implicit type conversions
 =========================
 
 Suppose that instances of two types ``A`` and ``B`` are used in a project, and
-that an ``A`` can easily be converted into a an instance of type ``B`` (examples of this
+that an ``A`` can easily be converted into an instance of type ``B`` (examples of this
 could be a fixed and an arbitrary precision number type).
 
 .. code-block:: cpp
@@ -707,6 +729,9 @@ There are two ways to resolve this issue:
 
     class Child : public std::enable_shared_from_this<Child> { };
 
+
+Please take a look at the :ref:`macro_notes` before using this feature.
+
 .. seealso::
 
     The file :file:`example/example8.cpp` contains a complete example that
@@ -778,6 +803,10 @@ exceptions:
 |                                      | accesses in ``__getitem__``, |
 |                                      | ``__setitem__``, etc.)       |
 +--------------------------------------+------------------------------+
+| :class:`pybind11::value_error`       | ``ValueError`` (used to      |
+|                                      | indicate wrong value passed  |
+|                                      | in ``container.remove(...)`` |
++--------------------------------------+------------------------------+
 | :class:`pybind11::error_already_set` | Indicates that the Python    |
 |                                      | exception flag has already   |
 |                                      | been initialized             |
@@ -791,13 +820,207 @@ There is also a special exception :class:`cast_error` that is thrown by
 :func:`handle::call` when the input arguments cannot be converted to Python
 objects.
 
+Registering custom exception translators
+========================================
+
+If the default exception conversion described above is not sufficient, the
+additional header file :file:`pybind11/exception_translator.h` provides
+support for registering custom exception translators.
+
+The function ``pybind11::register_exception_translator(translator)`` takes
+any callable (e.g. lambda, ``std::bind`` wrapped function, or function object) with
+the following call signature: ``void(std::exception_ptr)``.
+
+When a C++ exception is thrown, registered exception translators are tried
+in reverse order of registration (i.e. the last registered translator gets
+a first shot at handling the exception).
+
+Inside the translator ``std::rethrow_exception`` should be used, within
+a try block, to re-throw the exception. A catch clause can then use
+``PyErr_SetString`` or ``PyErr_SetObject`` to set a custom Python exception
+as demonstrated in :file:`example18.cpp``.
+
+Registering a translator looks like:
+
+.. code-block:: cpp
+
+    py::register_exception_translator([](std::exception_ptr p) { 
+        try {
+            if (p) std::rethrow_exception(p);
+        } catch (const MyCustomException &e) {
+            PyErr_SetString(PyExc_RuntimeError, e.what());
+        }
+    });
+
+Multiple exceptions can be handled by a single translator. If the exception
+is not caught by the current translator, the previously registered one gets a chance.
+
+If none of the registered exception translators is able to handle the exception it is handled by the default converter as described in the previous section.
+
+.. note::
+
+    You must either call ``PyErr_SetString`` or ``PyErr_SetObject``
+    for every exception caught in a custom exception translator.
+    Failure to do so will cause Python to crash with 
+    ``SystemError: error return without exception set``.
+
+    Exceptions that you do not plan to handle should simply not be caught.
+
+    You may also choose to explicity (re)throw to delegate to other
+    exception translators.
+
+.. _opaque:
+
+Treating STL data structures as opaque objects
+==============================================
+
+pybind11 heavily relies on a template matching mechanism to convert parameters
+and return values that are constructed from STL data types such as vectors,
+linked lists, hash tables, etc. This even works in a recursive manner, for
+instance to deal with lists of hash maps of pairs of elementary and custom
+types, etc.
+
+However, a fundamental limitation of this approach is that internal conversions
+between Python and C++ types involve a copy operation that prevents
+pass-by-reference semantics. What does this mean?
+
+Suppose we bind the following function
+
+.. code-block:: cpp
+
+    void append_1(std::vector<int> &v) {
+       v.push_back(1);
+    }
+
+and call it from Python, the following happens:
+
+.. code-block:: pycon
+
+   >>> v = [5, 6]
+   >>> append_1(v)
+   >>> print(v)
+   [5, 6]
+
+As you can see, when passing STL data structures by reference, modifications
+are not propagated back the Python side. A similar situation arises when
+exposing STL data structures using the ``def_readwrite`` or ``def_readonly``
+functions:
+
+.. code-block:: cpp
+
+    /* ... definition ... */
+
+    class MyClass {
+        std::vector<int> contents;
+    };
+
+    /* ... binding code ... */
+
+    py::class_<MyClass>(m, "MyClass")
+        .def(py::init<>)
+        .def_readwrite("contents", &MyClass::contents);
+
+In this case, properties can be read and written in their entirety. However, an
+``append`` operaton involving such a list type has no effect:
+
+.. code-block:: pycon
+
+   >>> m = MyClass()
+   >>> m.contents = [5, 6]
+   >>> print(m.contents)
+   [5, 6]
+   >>> m.contents.append(7)
+   >>> print(m.contents)
+   [5, 6]
+
+To deal with both of the above situations, pybind11 provides a macro named
+``PYBIND11_MAKE_OPAQUE(T)`` that disables the template-based conversion
+machinery of types, thus rendering them *opaque*. The contents of opaque
+objects are never inspected or extracted, hence they can be passed by
+reference. For instance, to turn ``std::vector<int>`` into an opaque type, add
+the declaration
+
+.. code-block:: cpp
+
+    PYBIND11_MAKE_OPAQUE(std::vector<int>);
+
+before any binding code (e.g. invocations to ``class_::def()``, etc.). This
+macro must be specified at the top level, since instantiates a partial template
+overload. If your binding code consists of multiple compilation units, it must
+be present in every file preceding any usage of ``std::vector<int>``. Opaque
+types must also have a corresponding ``class_`` declaration to associate them
+with a name in Python, and to define a set of available operations:
+
+.. code-block:: cpp
+
+    py::class_<std::vector<int>>(m, "IntVector")
+        .def(py::init<>())
+        .def("clear", &std::vector<int>::clear)
+        .def("pop_back", &std::vector<int>::pop_back)
+        .def("__len__", [](const std::vector<int> &v) { return v.size(); })
+        .def("__iter__", [](std::vector<int> &v) {
+           return py::make_iterator(v.begin(), v.end());
+        }, py::keep_alive<0, 1>()) /* Keep vector alive while iterator is used */
+        // ....
+
+Please take a look at the :ref:`macro_notes` before using this feature.
+
+.. seealso::
+
+    The file :file:`example/example14.cpp` contains a complete example that
+    demonstrates how to create and expose opaque types using pybind11 in more
+    detail.
+
+.. _eigen:
+
+Transparent conversion of dense and sparse Eigen data types
+===========================================================
+
+Eigen [#f1]_ is C++ header-based library for dense and sparse linear algebra. Due to
+its popularity and widespread adoption, pybind11 provides transparent
+conversion support between Eigen and Scientific Python linear algebra data types.
+
+Specifically, when including the optional header file :file:`pybind11/eigen.h`,
+pybind11 will automatically and transparently convert
+
+1. Static and dynamic Eigen dense vectors and matrices to instances of
+   ``numpy.ndarray`` (and vice versa).
+
+1. Eigen sparse vectors and matrices to instances of
+   ``scipy.sparse.csr_matrix``/``scipy.sparse.csc_matrix`` (and vice versa).
+
+This makes it possible to bind most kinds of functions that rely on these types.
+One major caveat are functions that take Eigen matrices *by reference* and modify
+them somehow, in which case the information won't be propagated to the caller.
+
+.. code-block:: cpp
+
+    /* The Python bindings of this function won't replicate
+       the intended effect of modifying the function argument */
+    void scale_by_2(Eigen::Vector3f &v) {
+       v *= 2;
+    }
+
+To see why this is, refer to the section on :ref:`opaque` (although that
+section specifically covers STL data types, the underlying issue is the same).
+The next two sections discuss an efficient alternative for exposing the
+underlying native Eigen types as opaque objects in a way that still integrates
+with NumPy and SciPy.
+
+.. [#f1] http://eigen.tuxfamily.org
+
+.. seealso::
+
+    The file :file:`example/eigen.cpp` contains a complete example that
+    shows how to pass Eigen sparse and dense data types in more detail.
+
 Buffer protocol
 ===============
 
 Python supports an extremely general and convenient approach for exchanging
-data between plugin libraries. Types can expose a buffer view [#f1]_,
-which provides fast direct access to the raw internal representation. Suppose
-we want to bind the following simplistic Matrix class:
+data between plugin libraries. Types can expose a buffer view [#f2]_, which
+provides fast direct access to the raw internal data representation. Suppose we
+want to bind the following simplistic Matrix class:
 
 .. code-block:: cpp
 
@@ -815,7 +1038,7 @@ we want to bind the following simplistic Matrix class:
     };
 
 The following binding code exposes the ``Matrix`` contents as a buffer object,
-making it possible to cast Matrixes into NumPy arrays. It is even possible to
+making it possible to cast Matrices into NumPy arrays. It is even possible to
 completely avoid copy operations with Python expressions like
 ``np.array(matrix_instance, copy = False)``.
 
@@ -824,12 +1047,12 @@ completely avoid copy operations with Python expressions like
     py::class_<Matrix>(m, "Matrix")
        .def_buffer([](Matrix &m) -> py::buffer_info {
             return py::buffer_info(
-                m.data(),                              /* Pointer to buffer */
-                sizeof(float),                         /* Size of one scalar */
-                py::format_descriptor<float>::value(), /* Python struct-style format descriptor */
-                2,                                     /* Number of dimensions */
-                { m.rows(), m.cols() },                /* Buffer dimensions */
-                { sizeof(float) * m.rows(),            /* Strides (in bytes) for each index */
+                m.data(),                            /* Pointer to buffer */
+                sizeof(float),                       /* Size of one scalar */
+                py::format_descriptor<float>::value, /* Python struct-style format descriptor */
+                2,                                   /* Number of dimensions */
+                { m.rows(), m.cols() },              /* Buffer dimensions */
+                { sizeof(float) * m.rows(),          /* Strides (in bytes) for each index */
                   sizeof(float) }
             );
         });
@@ -855,41 +1078,71 @@ in a great variety of configurations, hence some safety checks are usually
 necessary in the function body. Below, you can see an basic example on how to
 define a custom constructor for the Eigen double precision matrix
 (``Eigen::MatrixXd``) type, which supports initialization from compatible
-buffer
-objects (e.g. a NumPy matrix).
+buffer objects (e.g. a NumPy matrix).
 
 .. code-block:: cpp
 
-    py::class_<Eigen::MatrixXd>(m, "MatrixXd")
-        .def("__init__", [](Eigen::MatrixXd &m, py::buffer b) {
+    /* Bind MatrixXd (or some other Eigen type) to Python */
+    typedef Eigen::MatrixXd Matrix;
+
+    typedef Matrix::Scalar Scalar;
+    constexpr bool rowMajor = Matrix::Flags & Eigen::RowMajorBit;
+
+    py::class_<Matrix>(m, "Matrix")
+        .def("__init__", [](Matrix &m, py::buffer b) {
+            typedef Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic> Strides;
+
             /* Request a buffer descriptor from Python */
             py::buffer_info info = b.request();
 
             /* Some sanity checks ... */
-            if (info.format != py::format_descriptor<double>::value())
+            if (info.format != py::format_descriptor<Scalar>::value)
                 throw std::runtime_error("Incompatible format: expected a double array!");
 
             if (info.ndim != 2)
                 throw std::runtime_error("Incompatible buffer dimension!");
 
-            if (info.strides[0] == sizeof(double)) {
-                /* Buffer has the right layout -- directly copy. */
-                new (&m) Eigen::MatrixXd(info.shape[0], info.shape[1]);
-                memcpy(m.data(), info.ptr, sizeof(double) * m.size());
-            } else {
-                /* Oops -- the buffer is transposed */
-                new (&m) Eigen::MatrixXd(info.shape[1], info.shape[0]);
-                memcpy(m.data(), info.ptr, sizeof(double) * m.size());
-                m.transposeInPlace();
-            }
+            auto strides = Strides(
+                info.strides[rowMajor ? 0 : 1] / sizeof(Scalar),
+                info.strides[rowMajor ? 1 : 0] / sizeof(Scalar));
+
+            auto map = Eigen::Map<Matrix, 0, Strides>(
+                static_cat<Scalar *>(info.ptr), info.shape[0], info.shape[1], strides);
+
+            new (&m) Matrix(map);
         });
 
+For reference, the ``def_buffer()`` call for this Eigen data type should look
+as follows:
+
+.. code-block:: cpp
+
+    .def_buffer([](Matrix &m) -> py::buffer_info {
+        return py::buffer_info(
+            m.data(),                /* Pointer to buffer */
+            sizeof(Scalar),          /* Size of one scalar */
+            /* Python struct-style format descriptor */
+            py::format_descriptor<Scalar>::value,
+            /* Number of dimensions */
+            2,
+            /* Buffer dimensions */
+            { (size_t) m.rows(),
+              (size_t) m.cols() },
+            /* Strides (in bytes) for each index */
+            { sizeof(Scalar) * (rowMajor ? m.cols() : 1),
+              sizeof(Scalar) * (rowMajor ? 1 : m.rows()) }
+        );
+     })
+
+For a much easier approach of binding Eigen types (although with some
+limitations), refer to the section on :ref:`eigen`.
+
 .. seealso::
 
     The file :file:`example/example7.cpp` contains a complete example that
     demonstrates using the buffer protocol with pybind11 in more detail.
 
-.. [#f1] http://docs.python.org/3/c-api/buffer.html
+.. [#f2] http://docs.python.org/3/c-api/buffer.html
 
 NumPy support
 =============
@@ -901,16 +1154,32 @@ type of Python object satisfying the buffer protocol).
 In many situations, we want to define a function which only accepts a NumPy
 array of a certain data type. This is possible via the ``py::array_t<T>``
 template. For instance, the following function requires the argument to be a
-dense array of doubles in C-style ordering.
+NumPy array containing double precision values.
 
 .. code-block:: cpp
 
     void f(py::array_t<double> array);
 
-When it is invoked with a different type (e.g. an integer), the binding code
-will attempt to cast the input into a NumPy array of the requested type. Note
-that this feature requires the :file:``pybind11/numpy.h`` header to be
-included.
+When it is invoked with a different type (e.g. an integer or a list of
+integers), the binding code will attempt to cast the input into a NumPy array
+of the requested type. Note that this feature requires the
+:file:``pybind11/numpy.h`` header to be included.
+
+Data in NumPy arrays is not guaranteed to packed in a dense manner;
+furthermore, entries can be separated by arbitrary column and row strides.
+Sometimes, it can be useful to require a function to only accept dense arrays
+using either the C (row-major) or Fortran (column-major) ordering. This can be
+accomplished via a second template argument with values ``py::array::c_style``
+or ``py::array::f_style``.
+
+.. code-block:: cpp
+
+    void f(py::array_t<double, py::array::c_style | py::array::forcecast> array);
+
+The ``py::array::forcecast`` argument is the default value of the second
+template paramenter, and it ensures that non-conforming arguments are converted
+into an array satisfying the specified requirements instead of trying the next
+function overload.
 
 Vectorizing functions
 =====================
@@ -930,13 +1199,13 @@ After including the ``pybind11/numpy.h`` header, this is extremely simple:
     m.def("vectorized_func", py::vectorize(my_func));
 
 Invoking the function like below causes 4 calls to be made to ``my_func`` with
-each of the the array elements. The significant advantage of this compared to
+each of the array elements. The significant advantage of this compared to
 solutions like ``numpy.vectorize()`` is that the loop over the elements runs
 entirely on the C++ side and can be crunched down into a tight, optimized loop
 by the compiler. The result is returned as a NumPy array of type
 ``numpy.dtype.float64``.
 
-.. code-block:: python
+.. code-block:: pycon
 
     >>> x = np.array([[1, 3],[5, 7]])
     >>> y = np.array([[2, 4],[6, 8]])
@@ -948,7 +1217,7 @@ arrays ``x`` and ``y`` are automatically converted into the right types (they
 are of type  ``numpy.dtype.int64`` but need to be ``numpy.dtype.int32`` and
 ``numpy.dtype.float32``, respectively)
 
-Sometimes we might want to explitly exclude an argument from the vectorization
+Sometimes we might want to explicitly exclude an argument from the vectorization
 because it makes little sense to wrap it in a NumPy array. For instance,
 suppose the function signature was
 
@@ -1061,11 +1330,31 @@ The reverse direction uses the following syntax:
     MyClass *cls = obj.cast<MyClass *>();
 
 When conversion fails, both directions throw the exception :class:`cast_error`.
+It is also possible to call python functions via ``operator()``.
+
+.. code-block:: cpp
+
+    py::function f = <...>;
+    py::object result_py = f(1234, "hello", some_instance);
+    MyClass &result = result_py.cast<MyClass>();
+
+The special ``f(*args)`` and ``f(*args, **kwargs)`` syntax is also supported to
+supply arbitrary argument and keyword lists, although these cannot be mixed
+with other parameters.
+
+.. code-block:: cpp
+
+    py::function f = <...>;
+    py::tuple args = py::make_tuple(1234);
+    py::dict kwargs;
+    kwargs["y"] = py::cast(5678);
+    py::object result = f(*args, **kwargs);
 
 .. seealso::
 
     The file :file:`example/example2.cpp` contains a complete example that
-    demonstrates passing native Python types in more detail.
+    demonstrates passing native Python types in more detail. The file
+    :file:`example/example11.cpp` discusses usage of ``args`` and ``kwargs``.
 
 Default arguments revisited
 ===========================
@@ -1088,7 +1377,7 @@ Another aspect worth highlighting is that the "preview" of the default argument
 in the function signature is generated using the object's ``__repr__`` method.
 If not available, the signature may not be very helpful, e.g.:
 
-.. code-block:: python
+.. code-block:: pycon
 
     FUNCTIONS
     ...
@@ -1114,6 +1403,36 @@ like so:
     py::class_<MyClass>("MyClass")
         .def("myFunction", py::arg("arg") = (SomeType *) nullptr);
 
+Binding functions that accept arbitrary numbers of arguments and keywords arguments
+===================================================================================
+
+Python provides a useful mechanism to define functions that accept arbitrary
+numbers of arguments and keyword arguments:
+
+.. code-block:: cpp
+
+   def generic(*args, **kwargs):
+       # .. do something with args and kwargs
+
+Such functions can also be created using pybind11:
+
+.. code-block:: cpp
+
+   void generic(py::args args, py::kwargs kwargs) {
+       /// .. do something with args
+       if (kwargs)
+           /// .. do something with kwargs
+   }
+
+   /// Binding code
+   m.def("generic", &generic);
+
+(See ``example/example11.cpp``). The class ``py::args`` derives from
+``py::list`` and ``py::kwargs`` derives from ``py::dict`` Note that the
+``kwargs`` argument is invalid if no keyword arguments were actually provided.
+Please refer to the other examples for details on how to iterate over these,
+and on how to cast their entries into C++ objects.
+
 Partitioning code over multiple extension modules
 =================================================
 
@@ -1182,105 +1501,6 @@ accessed by multiple extension modules:
     };
 
 
-Treating STL data structures as opaque objects
-==============================================
-
-pybind11 heavily relies on a template matching mechanism to convert parameters
-and return values that are constructed from STL data types such as vectors,
-linked lists, hash tables, etc. This even works in a recursive manner, for
-instance to deal with lists of hash maps of pairs of elementary and custom
-types, etc.
-
-However, a fundamental limitation of this approach is that internal conversions
-between Python and C++ types involve a copy operation that prevents
-pass-by-reference semantics. What does this mean?
-
-Suppose we bind the following function
-
-.. code-block:: cpp
-
-    void append_1(std::vector<int> &v) {
-       v.push_back(1);
-    }
-
-and call it from Python, the following happens:
-
-.. code-block:: python
-
-   >>> v = [5, 6]
-   >>> append_1(v)
-   >>> print(v)
-   [5, 6]
-
-As you can see, when passing STL data structures by reference, modifications
-are not propagated back the Python side. A similar situation arises when
-exposing STL data structures using the ``def_readwrite`` or ``def_readonly``
-functions:
-
-.. code-block:: cpp
-
-    /* ... definition ... */
-
-    class MyClass {
-        std::vector<int> contents;
-    };
-
-    /* ... binding code ... */
-
-    py::class_<MyClass>(m, "MyClass")
-        .def(py::init<>)
-        .def_readwrite("contents", &MyClass::contents);
-
-In this case, properties can be read and written in their entirety. However, an
-``append`` operaton involving such a list type has no effect:
-
-.. code-block:: python
-
-   >>> m = MyClass()
-   >>> m.contents = [5, 6]
-   >>> print(m.contents)
-   [5, 6]
-   >>> m.contents.append(7)
-   >>> print(m.contents)
-   [5, 6]
-
-To deal with both of the above situations, pybind11 provides a macro named
-``PYBIND11_MAKE_OPAQUE(T)`` that disables the template-based conversion
-machinery of types, thus rendering them *opaque*. The contents of opaque
-objects are never inspected or extracted, hence they can be passed by
-reference. For instance, to turn ``std::vector<int>`` into an opaque type, add
-the declaration
-
-.. code-block:: cpp
-
-    PYBIND11_MAKE_OPAQUE(std::vector<int>);
-
-before any binding code (e.g. invocations to ``class_::def()``, etc). This
-macro must be specified at the top level, since instantiates a partial template
-overload. If your binding code consists of multiple compilation units, it must
-be present in every file preceding any usage of ``std::vector<int>``. Opaque
-types must also have a corresponding ``class_`` declaration to associate them
-with a name in Python, and to define a set of available operations:
-
-.. code-block:: cpp
-
-    py::class_<std::vector<int>>(m, "IntVector")
-        .def(py::init<>())
-        .def("clear", &std::vector<int>::clear)
-        .def("pop_back", &std::vector<int>::pop_back)
-        .def("__len__", [](const std::vector<int> &v) { return v.size(); })
-        .def("__iter__", [](std::vector<int> &v) {
-           return py::make_iterator(v.begin(), v.end());
-        }, py::keep_alive<0, 1>()) /* Keep vector alive while iterator is used */
-        // ....
-
-
-.. seealso::
-
-    The file :file:`example/example14.cpp` contains a complete example that
-    demonstrates how to create and expose opaque types using pybind11 in more
-    detail.
-
 Pickling support
 ================
 
@@ -1303,7 +1523,7 @@ Suppose the class in question has the following signature:
         int m_extra = 0;
     };
 
-The binding code including the requisite ``__setstate__`` and ``__getstate__`` methods [#f2]_
+The binding code including the requisite ``__setstate__`` and ``__getstate__`` methods [#f3]_
 looks as follows:
 
 .. code-block:: cpp
@@ -1340,27 +1560,29 @@ An instance can now be pickled as follows:
 
     p = Pickleable("test_value")
     p.setExtra(15)
-    data = pickle.dumps(p, -1)
+    data = pickle.dumps(p, 2)
 
-Note that only the cPickle module is supported on Python 2.7. It is also
-important to request usage of the highest protocol version using the ``-1``
-argument to ``dumps``. Failure to follow these two steps will lead to important
-pybind11 memory allocation routines to be skipped during unpickling, which will
-likely cause memory corruption and/or segmentation faults.
+Note that only the cPickle module is supported on Python 2.7. The second
+argument to ``dumps`` is also crucial: it selects the pickle protocol version
+2, since the older version 1 is not supported. Newer versions are also fine—for
+instance, specify ``-1`` to always use the latest available version. Beware:
+failure to follow these instructions will cause important pybind11 memory
+allocation routines to be skipped during unpickling, which will likely lead to
+memory corruption and/or segmentation faults.
 
 .. seealso::
 
     The file :file:`example/example15.cpp` contains a complete example that
     demonstrates how to pickle and unpickle types using pybind11 in more detail.
 
-.. [#f2] http://docs.python.org/3/library/pickle.html#pickling-class-instances
+.. [#f3] http://docs.python.org/3/library/pickle.html#pickling-class-instances
 
 Generating documentation using Sphinx
 =====================================
 
-Sphinx [#f3]_ has the ability to inspect the signatures and documentation
+Sphinx [#f4]_ has the ability to inspect the signatures and documentation
 strings in pybind11-based extension modules to automatically generate beautiful
-documentation in a variety formats. The pbtest repository [#f4]_ contains a
+documentation in a variety formats. The python_example repository [#f5]_ contains a
 simple example repository which uses this approach.
 
 There are two potential gotchas when using this approach: first, make sure that
@@ -1387,6 +1609,5 @@ work, it is important that all lines are indented consistently, i.e.:
         ----------
     )mydelimiter");
 
-.. [#f3] http://www.sphinx-doc.org
-.. [#f4] http://github.com/pybind/pbtest
-
+.. [#f4] http://www.sphinx-doc.org
+.. [#f5] http://github.com/pybind/python_example
diff --git a/docs/basics.rst b/docs/basics.rst
index cf39844..1f40f19 100644
--- a/docs/basics.rst
+++ b/docs/basics.rst
@@ -128,7 +128,7 @@ Assuming that the created file :file:`example.so` (:file:`example.pyd` on Window
 is located in the current directory, the following interactive Python session
 shows how to load and execute the example.
 
-.. code-block:: python
+.. code-block:: pycon
 
     $ python
     Python 2.7.10 (default, Aug 22 2015, 20:33:39)
@@ -157,7 +157,7 @@ metadata into :func:`module::def`. With this modified binding code, we can now
 call the function using keyword arguments, which is a more readable alternative
 particularly for functions taking many parameters:
 
-.. code-block:: python
+.. code-block:: pycon
 
     >>> import example
     >>> example.add(i=1, j=2)
@@ -165,7 +165,7 @@ particularly for functions taking many parameters:
 
 The keyword names also appear in the function signatures within the documentation.
 
-.. code-block:: python
+.. code-block:: pycon
 
     >>> help(example)
 
@@ -177,6 +177,21 @@ The keyword names also appear in the function signatures within the documentatio
 
             A function which adds two numbers
 
+A shorter notation for named arguments is also available:
+
+.. code-block:: cpp
+    
+    // regular notation
+    m.def("add1", &add, py::arg("i"), py::arg("j"));
+    // shorthand
+    using namespace pybind11::literals;
+    m.def("add2", &add, "i"_a, "j"_a);
+
+The :var:`_a` suffix forms a C++11 literal which is equivalent to :class:`arg`. 
+Note that the literal operator must first be made visible with the directive 
+``using namespace pybind11::literals``. This does not bring in anything else 
+from the ``pybind11`` namespace except for literals.
+
 .. _default_args:
 
 Default arguments
@@ -201,7 +216,7 @@ using an extension of :class:`arg`:
 
 The default values also appear within the documentation.
 
-.. code-block:: python
+.. code-block:: pycon
 
     >>> help(example)
 
@@ -213,6 +228,15 @@ The default values also appear within the documentation.
 
             A function which adds two numbers
 
+The shorthand notation is also available for default arguments:
+
+.. code-block:: cpp
+    
+    // regular notation
+    m.def("add1", &add, py::arg("i") = 1, py::arg("j") = 2);
+    // shorthand
+    m.def("add2", &add, "i"_a=1, "j"_a=2);
+
 .. _supported_types:
 
 Supported data types
@@ -275,8 +299,11 @@ as arguments and return values, refer to the section on binding :ref:`classes`.
 +---------------------------------+--------------------------+-------------------------------+
 | ``std::function<...>``          | STL polymorphic function | :file:`pybind11/functional.h` |
 +---------------------------------+--------------------------+-------------------------------+
+| ``Eigen::Matrix<...>``          | Dense Eigen matrices     | :file:`pybind11/eigen.h`      |
++---------------------------------+--------------------------+-------------------------------+
+| ``Eigen::SparseMatrix<...>``    | Sparse Eigen matrices    | :file:`pybind11/eigen.h`      |
++---------------------------------+--------------------------+-------------------------------+
 
 
 .. [#f1] In practice, implementation and binding code will generally be located
          in separate files.
-
diff --git a/docs/changelog.rst b/docs/changelog.rst
index 8be3ef4..ffae32b 100644
--- a/docs/changelog.rst
+++ b/docs/changelog.rst
@@ -3,6 +3,62 @@
 Changelog
 #########
 
+Starting with version 1.8, pybind11 releases use a
+[semantic versioning](http://semver.org) policy.
+
+Breaking changes queued for v2.0.0 (Not yet released)
+---------------------------------------------------
+* Redesigned virtual call mechanism and user-facing syntax (see
+  https://github.com/pybind/pybind11/commit/86d825f3302701d81414ddd3d38bcd09433076bc)
+
+* Remove ``handle.call()`` method
+
+1.9.0 (Not yet released)
+----------------------
+* Queued changes: ``py::eval*``, map indexing suite, documentation for indexing suites.
+
+1.8.0 (June 14, 2016)
+----------------------
+* Redesigned CMake build system which exports a convenient
+  ``pybind11_add_module`` function to parent projects.
+* ``std::vector<>`` type bindings analogous to Boost.Python's ``indexing_suite``
+* Transparent conversion of sparse and dense Eigen matrices and vectors (``eigen.h``)
+* Added an ``ExtraFlags`` template argument to the NumPy ``array_t<>`` wrapper
+  to disable an enforced cast that may lose precision, e.g. to create overloads
+  for different precisions and complex vs real-valued matrices.
+* Prevent implicit conversion of floating point values to integral types in
+  function arguments
+* Fixed incorrect default return value policy for functions returning a shared
+  pointer
+* Don't allow registering a type via ``class_`` twice
+* Don't allow casting a ``None`` value into a C++ lvalue reference
+* Fixed a crash in ``enum_::operator==`` that was triggered by the ``help()`` command
+* Improved detection of whether or not custom C++ types can be copy/move-constructed
+* Extended ``str`` type to also work with ``bytes`` instances
+* Added a ``"name"_a`` user defined string literal that is equivalent to ``py::arg("name")``.
+* When specifying function arguments via ``py::arg``, the test that verifies
+  the number of arguments now runs at compile time.
+* Added ``[[noreturn]]`` attribute to ``pybind11_fail()`` to quench some
+  compiler warnings
+* List function arguments in exception text when the dispatch code cannot find
+  a matching overload
+* Added ``PYBIND11_OVERLOAD_NAME`` and ``PYBIND11_OVERLOAD_PURE_NAME`` macros which
+  can be used to override virtual methods whose name differs in C++ and Python
+  (e.g. ``__call__`` and ``operator()``)
+* Various minor ``iterator`` and ``make_iterator()`` improvements
+* Transparently support ``__bool__`` on Python 2.x and Python 3.x
+* Fixed issue with destructor of unpickled object not being called
+* Minor CMake build system improvements on Windows
+* New ``pybind11::args`` and ``pybind11::kwargs`` types to create functions which
+  take an arbitrary number of arguments and keyword arguments
+* New syntax to call a Python function from C++ using ``*args`` and ``*kwargs``
+* The functions ``def_property_*`` now correctly process docstring arguments (these
+  formerly caused a segmentation fault)
+* Many ``mkdoc.py`` improvements (enumerations, template arguments, ``DOC()``
+  macro accepts more arguments)
+* Cygwin support
+* Documentation improvements (pickling support, ``keep_alive``, macro usage)
+
 1.7 (April 30, 2016)
 ----------------------
 * Added a new ``move`` return value policy that triggers C++11 move semantics.
diff --git a/docs/classes.rst b/docs/classes.rst
index c98f8da..a3a0bf3 100644
--- a/docs/classes.rst
+++ b/docs/classes.rst
@@ -44,7 +44,7 @@ constructor's parameters as template arguments and wraps the corresponding
 constructor (see the :ref:`custom_constructors` section for details). An
 interactive Python session demonstrating this example is shown below:
 
-.. code-block:: python
+.. code-block:: pycon
 
     % python
     >>> import example
@@ -73,7 +73,7 @@ Binding lambda functions
 
 Note how ``print(p)`` produced a rather useless summary of our data structure in the example above:
 
-.. code-block:: python
+.. code-block:: pycon
 
     >>> print(p)
     <example.Pet object at 0x10cd98060>
@@ -99,7 +99,7 @@ Lambda function instead:
 Both stateless [#f1]_ and stateful lambda closures are supported by pybind11.
 With the above change, the same Python code now produces the following output:
 
-.. code-block:: python
+.. code-block:: pycon
 
     >>> print(p)
     <example.Pet named 'Molly'>
@@ -120,7 +120,7 @@ method also exists for ``const`` fields.
 
 This makes it possible to write
 
-.. code-block:: python
+.. code-block:: pycon
 
     >>> p = example.Pet('Molly')
     >>> p.name
@@ -212,7 +212,7 @@ Alternatively, we can also assign a name to the previously bound ``Pet``
 Functionality-wise, both approaches are completely equivalent. Afterwards,
 instances will expose fields and methods of both types:
 
-.. code-block:: python
+.. code-block:: pycon
 
     >>> p = example.Dog('Molly')
     >>> p.name
@@ -253,7 +253,7 @@ sequence.
 
 The overload signatures are also visible in the method's docstring:
 
-.. code-block:: python
+.. code-block:: pycon
 
     >>> help(example.Pet)
 
@@ -319,7 +319,7 @@ constructor. The :func:`enum_::export_values` function exports the enum entries
 into the parent scope, which should be skipped for newer C++11-style strongly
 typed enums.
 
-.. code-block:: python
+.. code-block:: pycon
 
     >>> p = Pet('Lucy', Pet.Cat)
     >>> p.type
diff --git a/docs/cmake.rst b/docs/cmake.rst
deleted file mode 100644
index 7236ea8..0000000
--- a/docs/cmake.rst
+++ /dev/null
@@ -1,159 +0,0 @@
-Build systems
-#############
-
-Building with setuptools
-========================
-
-For projects on PyPI, building with setuptools is the way to go. Sylvain Corlay
-has kindly provided an example project which shows how to set up everything,
-including automatic generation of documentation using Sphinx. Please refer to
-the [pbtest]_ repository.
-
-.. [pbtest] https://github.com/pybind/pbtest
-
-.. _cmake:
-
-Building with CMake
-===================
-
-For C++ codebases that already have an existing CMake-based build system, the
-following snippet should be a good starting point to create bindings across
-platforms. It assumes that the code is located in a file named
-:file:`example.cpp`, and that the pybind11 repository is located in a
-subdirectory named :file:`pybind11`.
-
-.. code-block:: cmake
-
-    cmake_minimum_required(VERSION 2.8)
-
-    project(example)
-
-    # Add a CMake parameter for choosing a desired Python version
-    set(EXAMPLE_PYTHON_VERSION "" CACHE STRING
-        "Python version to use for compiling the example library")
-
-    include(CheckCXXCompilerFlag)
-
-    # Set a default build configuration if none is specified.
-    # 'MinSizeRel' produces the smallest binaries
-    if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
-      message(STATUS "Setting build type to 'MinSizeRel' as none was specified.")
-      set(CMAKE_BUILD_TYPE MinSizeRel CACHE STRING "Choose the type of build." FORCE)
-      set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release"
-        "MinSizeRel" "RelWithDebInfo")
-    endif()
-    string(TOUPPER "${CMAKE_BUILD_TYPE}" U_CMAKE_BUILD_TYPE)
-
-    # Try to autodetect Python (can be overridden manually if needed)
-    set(Python_ADDITIONAL_VERSIONS 3.4 3.5 3.6 3.7)
-    if (NOT ${EXAMPLE_PYTHON_VERSION} STREQUAL "")
-      find_package(PythonLibs ${EXAMPLE_PYTHON_VERSION} EXACT)
-      if (NOT PythonLibs_FOUND)
-        find_package(PythonLibs ${EXAMPLE_PYTHON_VERSION} REQUIRED)
-      endif()
-    else()
-      find_package(PythonLibs REQUIRED)
-    endif()
-
-    # The above sometimes returns version numbers like "3.4.3+";
-    # the "+" must be removed for the next lines to work
-    string(REPLACE "+" "" PYTHONLIBS_VERSION_STRING "+${PYTHONLIBS_VERSION_STRING}")
-
-    # Uncomment the following line if you will also require a matching Python interpreter
-    # find_package(PythonInterp ${PYTHONLIBS_VERSION_STRING} EXACT REQUIRED)
-
-    if (CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_CXX_COMPILER_ID MATCHES "GNU")
-      CHECK_CXX_COMPILER_FLAG("-std=c++14" HAS_CPP14_FLAG)
-      CHECK_CXX_COMPILER_FLAG("-std=c++11" HAS_CPP11_FLAG)
-
-      if (HAS_CPP14_FLAG)
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++14")
-      elseif (HAS_CPP11_FLAG)
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
-      else()
-        message(FATAL_ERROR "Unsupported compiler -- at least C++11 support is needed!")
-      endif()
-
-      # Enable link time optimization and set the default symbol
-      # visibility to hidden (very important to obtain small binaries)
-      if (NOT ${U_CMAKE_BUILD_TYPE} MATCHES DEBUG)
-        # Default symbol visibility
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fvisibility=hidden")
-
-        # Check for Link Time Optimization support
-        CHECK_CXX_COMPILER_FLAG("-flto" HAS_LTO_FLAG)
-        if (HAS_LTO_FLAG)
-          set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -flto")
-        endif()
-      endif()
-    endif()
-
-    # Include path for Python header files
-    include_directories(${PYTHON_INCLUDE_DIR})
-
-    # Include path for pybind11 header files -- this may need to be
-    # changed depending on your setup
-    include_directories(${PROJECT_SOURCE_DIR}/pybind11/include)
-
-    # Create the binding library
-    add_library(example SHARED
-      example.cpp
-      # ... extra files go here ...
-    )
-
-    # Don't add a 'lib' prefix to the shared library
-    set_target_properties(example PROPERTIES PREFIX "")
-
-    if (WIN32)
-      if (MSVC)
-        # /bigobj is needed for bigger binding projects due to the limit to 64k
-        # addressable sections. /MP enables multithreaded builds (relevant when
-        # there are many files).
-        set_target_properties(example PROPERTIES COMPILE_FLAGS "/MP /bigobj ")
-
-        if (NOT ${U_CMAKE_BUILD_TYPE} MATCHES DEBUG)
-          # Enforce size-based optimization and link time code generation on MSVC
-          # (~30% smaller binaries in experiments).
-          set_target_properties(example APPEND_STRING PROPERTY COMPILE_FLAGS "/Os /GL ")
-          set_target_properties(example APPEND_STRING PROPERTY LINK_FLAGS "/LTCG ")
-        endif()
-      endif()
-
-      # .PYD file extension on Windows
-      set_target_properties(example PROPERTIES SUFFIX ".pyd")
-
-      # Link against the Python shared library
-      target_link_libraries(example ${PYTHON_LIBRARY})
-    elseif (UNIX)
-      # It's quite common to have multiple copies of the same Python version
-      # installed on one's system. E.g.: one copy from the OS and another copy
-      # that's statically linked into an application like Blender or Maya.
-      # If we link our plugin library against the OS Python here and import it
-      # into Blender or Maya later on, this will cause segfaults when multiple
-      # conflicting Python instances are active at the same time (even when they
-      # are of the same version).
-
-      # Windows is not affected by this issue since it handles DLL imports
-      # differently. The solution for Linux and Mac OS is simple: we just don't
-      # link against the Python library. The resulting shared library will have
-      # missing symbols, but that's perfectly fine -- they will be resolved at
-      # import time.
-
-      # .SO file extension on Linux/Mac OS
-      set_target_properties(example PROPERTIES SUFFIX ".so")
-
-      # Strip unnecessary sections of the binary on Linux/Mac OS
-      if(APPLE)
-        set_target_properties(example PROPERTIES MACOSX_RPATH ".")
-        set_target_properties(example PROPERTIES LINK_FLAGS "-undefined dynamic_lookup ")
-        if (NOT ${U_CMAKE_BUILD_TYPE} MATCHES DEBUG)
-          add_custom_command(TARGET example POST_BUILD
-                             COMMAND strip -u -r ${PROJECT_BINARY_DIR}/example.so)
-        endif()
-      else()
-        if (NOT ${U_CMAKE_BUILD_TYPE} MATCHES DEBUG)
-          add_custom_command(TARGET example POST_BUILD
-                             COMMAND strip ${PROJECT_BINARY_DIR}/example.so)
-        endif()
-      endif()
-    endif()
diff --git a/docs/compiling.rst b/docs/compiling.rst
new file mode 100644
index 0000000..9ec3bc2
--- /dev/null
+++ b/docs/compiling.rst
@@ -0,0 +1,53 @@
+Build systems
+#############
+
+Building with setuptools
+========================
+
+For projects on PyPI, building with setuptools is the way to go. Sylvain Corlay
+has kindly provided an example project which shows how to set up everything,
+including automatic generation of documentation using Sphinx. Please refer to
+the [python_example]_ repository.
+
+.. [python_example] https://github.com/pybind/python_example
+
+Building with cppimport
+========================
+
+ cppimport is a small Python import hook that determines whether there is a C++
+ source file whose name matches the requested module. If there is, the file is
+ compiled as a Python extension using pybind11 and placed in the same folder as
+ the C++ source file. Python is then able to find the module and load it.
+
+.. [cppimport] https://github.com/tbenthompson/cppimport
+
+.. _cmake:
+
+Building with CMake
+===================
+
+For C++ codebases that have an existing CMake-based build system, a Python 
+extension module can be created with just a few lines of code:
+
+.. code-block:: cmake
+
+    cmake_minimum_required(VERSION 2.8.12)
+    project(example)
+
+    add_subdirectory(pybind11)
+    pybind11_add_module(example example.cpp)
+
+This assumes that the pybind11 repository is located in a subdirectory named 
+:file:`pybind11` and that the code is located in a file named :file:`example.cpp`.
+The CMake command ``add_subdirectory`` will import a function with the signature
+``pybind11_add_module(<name> source1 [source2 ...])``. It will take care of all
+the details needed to build a Python extension module on any platform.
+
+The target Python version can be selected by setting the ``PYBIND11_PYTHON_VERSION`` 
+variable before adding the pybind11 subdirectory. Alternatively, an exact Python 
+installation can be specified by setting ``PYTHON_EXECUTABLE``.
+
+A working sample project, including a way to invoke CMake from :file:`setup.py` for
+PyPI integration, can be found in the [cmake_example]_  repository.
+
+.. [cmake_example] https://github.com/pybind/cmake_example
diff --git a/docs/conf.py b/docs/conf.py
index 9d25838..4e2c4ce 100644
--- a/docs/conf.py
+++ b/docs/conf.py
@@ -56,9 +56,9 @@ author = 'Wenzel Jakob'
 # built documents.
 #
 # The short X.Y version.
-version = '1.0'
+version = '1.9'
 # The full version, including alpha/beta/rc tags.
-release = '1.0'
+release = '1.9.dev0'
 
 # The language for content autogenerated by Sphinx. Refer to documentation
 # for a list of supported languages.
diff --git a/docs/faq.rst b/docs/faq.rst
index 4badaf6..788b3b8 100644
--- a/docs/faq.rst
+++ b/docs/faq.rst
@@ -1,10 +1,8 @@
 Frequently asked questions
 ##########################
 
-(under construction)
-
-ImportError: dynamic module does not define init function
-=========================================================
+"ImportError: dynamic module does not define init function"
+===========================================================
 
 1. Make sure that the name specified in ``pybind::module`` and
    ``PYBIND11_PLUGIN`` is consistent and identical to the filename of the
@@ -14,7 +12,29 @@ ImportError: dynamic module does not define init function
 2. If the above did not fix your issue, then you are likely using an
    incompatible version of Python (for instance, the extension library was
    compiled against Python 2, while the interpreter is running on top of some
-   version of Python 3)
+   version of Python 3, or vice versa)
+
+"Symbol not found: ``__Py_ZeroStruct`` / ``_PyInstanceMethod_Type``"
+========================================================================
+
+See item 2 of the first answer.
+
+The Python interpreter immediately crashes when importing my module
+===================================================================
+
+See item 2 of the first answer.
+
+CMake doesn't detect the right Python version
+=============================================
+
+The CMake-based build system will try to automatically detect the installed
+version of Python and link against that. When this fails, or when there are
+multiple versions of Python and it finds the wrong one, delete
+``CMakeCache.txt`` and then invoke CMake as follows:
+
+.. code-block:: bash
+
+    cmake -DPYTHON_EXECUTABLE:FILEPATH=<path-to-python-executable> .
 
 Limitations involving reference arguments
 =========================================
@@ -64,38 +84,6 @@ and the binding code
 
    m.def("foo", [](int i) { int rv = foo(i); return std::make_tuple(rv, i); });
 
-CMake doesn't detect the right Python version, or it finds mismatched interpreter and library versions
-======================================================================================================
-
-The Python detection logic of CMake is flawed and can sometimes fail to find
-the desired Python version, or it chooses mismatched interpreter and library
-versions. A longer discussion is available on the pybind11 issue tracker
-[#f1]_, though this is ultimately not a pybind11 issue.
-
-To force the build system to choose a particular version, delete CMakeCache.txt
-and then invoke CMake as follows:
-
-.. code-block:: bash
-
-    cmake -DPYTHON_EXECUTABLE:FILEPATH=<...> \
-          -DPYTHON_LIBRARY:FILEPATH=<...>  \
-          -DPYTHON_INCLUDE_DIR:PATH=<...> .
-
-.. [#f1] http://github.com/pybind/pybind11/issues/99
-
-Working with ancient Visual Studio 2009 builds on Windows
-=========================================================
-
-The official Windows distributions of Python are compiled using truly
-ancient versions of Visual Studio that lack good C++11 support. Some users
-implicitly assume that it would be impossible to load a plugin built with
-Visual Studio 2015 into a Python distribution that was compiled using Visual
-Studio 2009. However, no such issue exists: it's perfectly legitimate to
-interface DLLs that are built with different compilers and/or C libraries.
-Common gotchas to watch out for involve not ``free()``-ing memory region
-that that were ``malloc()``-ed in another shared library, using data
-structures with incompatible ABIs, and so on. pybind11 is very careful not
-to make these types of mistakes.
 
 How can I reduce the build time?
 ================================
@@ -204,3 +192,17 @@ enable C++14 language features (using ``-std=c++14`` for GCC/Clang), in which
 case signatures are efficiently pre-generated at compile time. Unfortunately,
 Visual Studio's C++14 support (``constexpr``) is not good enough as of April
 2016, so it always uses the more expensive run-time approach.
+
+Working with ancient Visual Studio 2009 builds on Windows
+=========================================================
+
+The official Windows distributions of Python are compiled using truly
+ancient versions of Visual Studio that lack good C++11 support. Some users
+implicitly assume that it would be impossible to load a plugin built with
+Visual Studio 2015 into a Python distribution that was compiled using Visual
+Studio 2009. However, no such issue exists: it's perfectly legitimate to
+interface DLLs that are built with different compilers and/or C libraries.
+Common gotchas to watch out for involve not ``free()``-ing memory region
+that that were ``malloc()``-ed in another shared library, using data
+structures with incompatible ABIs, and so on. pybind11 is very careful not
+to make these types of mistakes.
diff --git a/docs/index.rst b/docs/index.rst
index 5115171..ab9a1fc 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -16,7 +16,7 @@ pybind11 --- Seamless operability between C++11 and Python
    basics
    classes
    advanced
-   cmake
+   compiling
    benchmark
    limitations
    faq
diff --git a/docs/release.rst b/docs/release.rst
index e0f8a86..43934ec 100644
--- a/docs/release.rst
+++ b/docs/release.rst
@@ -2,20 +2,20 @@ To release a new version of pybind11:
 
 - Update the version number and push to pypi
     - Update ``pybind11/_version.py`` (set release version, remove 'dev')
+    - Update version in ``docs/conf.py``
+    - Tag release date in ``docs/changelog.rst``.
     - ``git add`` and ``git commit``.
+    - ``git tag -a vX.Y -m 'vX.Y release'``.
+    - ``git push``
+    - ``git push --tags``.
     - ``python setup.py sdist upload``.
     - ``python setup.py bdist_wheel upload``.
-    - Tag release date in ``doc/changelog.rst``.
-- Tag the commit and push to anaconda.org
-    - ``git tag -a vX.Y -m 'vX.Y release'``.
-    - ``conda-build conda.recipe``
-      This should ouput the path of the generated tar.bz2 for the package
-    - ``conda-convert --platform all [path/to/tar.bz2] -o .``
-    - ``for i in *-32/* *-64/*; do anaconda upload -u pybind $i; done``
+- Update conda-forge (https://github.com/conda-forge/pybind11-feedstock) via PR
+    - change version number in ``recipe/meta.yml``
+    - update checksum to match the one computed by pypi
 - Get back to work
     - Update ``_version.py`` (add 'dev' and increment minor).
+    - Update version in ``docs/conf.py``
     - Update version macros in ``include/pybind11/common.h``
-    - ``git add`` and ``git commit``. ``git push``. ``git push --tags``.
-
-The remote for the last ``git push --tags`` should be the main repository for
-pybind11.
+    - ``git add`` and ``git commit``.
+      ``git push``
diff --git a/example/CMakeLists.txt b/example/CMakeLists.txt
new file mode 100644
index 0000000..6b23723
--- /dev/null
+++ b/example/CMakeLists.txt
@@ -0,0 +1,69 @@
+# Set a default build configuration if none is specified. 'MinSizeRel' produces the smallest binaries
+if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
+  message(STATUS "Setting build type to 'MinSizeRel' as none was specified.")
+  set(CMAKE_BUILD_TYPE MinSizeRel CACHE STRING "Choose the type of build." FORCE)
+  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release"
+    "MinSizeRel" "RelWithDebInfo")
+endif()
+
+set(PYBIND11_EXAMPLES
+  example1.cpp
+  example2.cpp
+  example3.cpp
+  example4.cpp
+  example5.cpp
+  example6.cpp
+  example7.cpp
+  example8.cpp
+  example9.cpp
+  example10.cpp
+  example11.cpp
+  example12.cpp
+  example13.cpp
+  example14.cpp
+  example15.cpp
+  example16.cpp
+  example17.cpp
+  example18.cpp
+  issues.cpp
+)
+
+# Check if Eigen is available
+find_package(Eigen3 QUIET)
+
+if(EIGEN3_FOUND)
+  list(APPEND PYBIND11_EXAMPLES eigen.cpp)
+  message(STATUS "Building Eigen testcase")
+else()
+  message(STATUS "NOT Building Eigen testcase")
+endif()
+
+# Create the binding library
+pybind11_add_module(example example.cpp ${PYBIND11_EXAMPLES})
+pybind11_enable_warnings(example)
+
+if(EIGEN3_FOUND)
+  target_include_directories(example PRIVATE ${EIGEN3_INCLUDE_DIR})
+  target_compile_definitions(example PRIVATE -DPYBIND11_TEST_EIGEN)
+endif()
+
+# Always write the output file directly into the 'example' directory (even on MSVC)
+set(CompilerFlags
+  LIBRARY_OUTPUT_DIRECTORY LIBRARY_OUTPUT_DIRECTORY_RELEASE LIBRARY_OUTPUT_DIRECTORY_DEBUG
+  LIBRARY_OUTPUT_DIRECTORY_MINSIZEREL LIBRARY_OUTPUT_DIRECTORY_RELWITHDEBINFO
+  RUNTIME_OUTPUT_DIRECTORY RUNTIME_OUTPUT_DIRECTORY_RELEASE RUNTIME_OUTPUT_DIRECTORY_DEBUG
+  RUNTIME_OUTPUT_DIRECTORY_MINSIZEREL RUNTIME_OUTPUT_DIRECTORY_RELWITHDEBINFO)
+
+foreach(CompilerFlag ${CompilerFlags})
+  set_target_properties(example PROPERTIES ${CompilerFlag} ${PROJECT_SOURCE_DIR}/example)
+endforeach()
+
+set(RUN_TEST ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/run_test.py)
+if(MSVC OR CMAKE_CXX_COMPILER_ID MATCHES "Intel")
+  set(RUN_TEST ${RUN_TEST} --relaxed)
+endif()
+
+foreach(VALUE ${PYBIND11_EXAMPLES})
+  string(REGEX REPLACE "^(.+).cpp$" "\\1" EXAMPLE_NAME "${VALUE}")
+  add_test(NAME ${EXAMPLE_NAME} COMMAND ${RUN_TEST} ${EXAMPLE_NAME})
+endforeach()
diff --git a/example/eigen.cpp b/example/eigen.cpp
new file mode 100644
index 0000000..b6fa24a
--- /dev/null
+++ b/example/eigen.cpp
@@ -0,0 +1,73 @@
+/*
+    example/eigen.cpp -- automatic conversion of Eigen types
+
+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#include "example.h"
+#include <pybind11/eigen.h>
+
+void init_eigen(py::module &m) {
+    typedef Eigen::Matrix<float, 5, 6, Eigen::RowMajor> FixedMatrixR;
+    typedef Eigen::Matrix<float, 5, 6> FixedMatrixC;
+    typedef Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> DenseMatrixR;
+    typedef Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic> DenseMatrixC;
+    typedef Eigen::SparseMatrix<float, Eigen::RowMajor> SparseMatrixR;
+    typedef Eigen::SparseMatrix<float> SparseMatrixC;
+
+    // Non-symmetric matrix with zero elements
+    Eigen::MatrixXf mat(5, 6);
+    mat << 0, 3, 0, 0, 0, 11, 22, 0, 0, 0, 17, 11, 7, 5, 0, 1, 0, 11, 0,
+        0, 0, 0, 0, 11, 0, 0, 14, 0, 8, 11;
+
+    m.def("fixed_r", [mat]() -> FixedMatrixR { 
+        return FixedMatrixR(mat);
+    });
+
+    m.def("fixed_c", [mat]() -> FixedMatrixC { 
+        return FixedMatrixC(mat);
+    });
+
+    m.def("fixed_passthrough_r", [](const FixedMatrixR &m) -> FixedMatrixR { 
+        return m;
+    });
+
+    m.def("fixed_passthrough_c", [](const FixedMatrixC &m) -> FixedMatrixC { 
+        return m;
+    });
+
+    m.def("dense_r", [mat]() -> DenseMatrixR { 
+        return DenseMatrixR(mat);
+    });
+
+    m.def("dense_c", [mat]() -> DenseMatrixC { 
+        return DenseMatrixC(mat);
+    });
+
+    m.def("dense_passthrough_r", [](const DenseMatrixR &m) -> DenseMatrixR { 
+        return m;
+    });
+
+    m.def("dense_passthrough_c", [](const DenseMatrixC &m) -> DenseMatrixC { 
+        return m;
+    });
+
+    m.def("sparse_r", [mat]() -> SparseMatrixR { 
+        return Eigen::SparseView<Eigen::MatrixXf>(mat);
+    });
+
+    m.def("sparse_c", [mat]() -> SparseMatrixC { 
+        return Eigen::SparseView<Eigen::MatrixXf>(mat);
+    });
+
+    m.def("sparse_passthrough_r", [](const SparseMatrixR &m) -> SparseMatrixR { 
+        return m;
+    });
+
+    m.def("sparse_passthrough_c", [](const SparseMatrixC &m) -> SparseMatrixC { 
+        return m;
+    });
+}
diff --git a/example/eigen.py b/example/eigen.py
new file mode 100644
index 0000000..accaf23
--- /dev/null
+++ b/example/eigen.py
@@ -0,0 +1,44 @@
+#!/usr/bin/env python
+from __future__ import print_function
+import sys
+sys.path.append('.')
+
+from example import fixed_r, fixed_c
+from example import fixed_passthrough_r, fixed_passthrough_c
+from example import dense_r, dense_c
+from example import dense_passthrough_r, dense_passthrough_c
+from example import sparse_r, sparse_c
+from example import sparse_passthrough_r, sparse_passthrough_c
+import numpy as np
+
+ref = np.array(
+    [[0, 3, 0, 0, 0, 11],
+     [22, 0, 0, 0, 17, 11],
+     [7, 5, 0, 1, 0, 11],
+     [0, 0, 0, 0, 0, 11],
+     [0, 0, 14, 0, 8, 11]])
+
+
+def check(mat):
+    return 'OK' if np.sum(mat - ref) == 0 else 'NOT OK'
+
+print("fixed_r = %s" % check(fixed_r()))
+print("fixed_c = %s" % check(fixed_c()))
+print("pt_r(fixed_r) = %s" % check(fixed_passthrough_r(fixed_r())))
+print("pt_c(fixed_c) = %s" % check(fixed_passthrough_c(fixed_c())))
+print("pt_r(fixed_c) = %s" % check(fixed_passthrough_r(fixed_c())))
+print("pt_c(fixed_r) = %s" % check(fixed_passthrough_c(fixed_r())))
+
+print("dense_r = %s" % check(dense_r()))
+print("dense_c = %s" % check(dense_c()))
+print("pt_r(dense_r) = %s" % check(dense_passthrough_r(dense_r())))
+print("pt_c(dense_c) = %s" % check(dense_passthrough_c(dense_c())))
+print("pt_r(dense_c) = %s" % check(dense_passthrough_r(dense_c())))
+print("pt_c(dense_r) = %s" % check(dense_passthrough_c(dense_r())))
+
+print("sparse_r = %s" % check(sparse_r()))
+print("sparse_c = %s" % check(sparse_c()))
+print("pt_r(sparse_r) = %s" % check(sparse_passthrough_r(sparse_r())))
+print("pt_c(sparse_c) = %s" % check(sparse_passthrough_c(sparse_c())))
+print("pt_r(sparse_c) = %s" % check(sparse_passthrough_r(sparse_c())))
+print("pt_c(sparse_r) = %s" % check(sparse_passthrough_c(sparse_r())))
diff --git a/example/eigen.ref b/example/eigen.ref
new file mode 100644
index 0000000..b87f8ed
--- /dev/null
+++ b/example/eigen.ref
@@ -0,0 +1,18 @@
+fixed_r = OK
+fixed_c = OK
+pt_r(fixed_r) = OK
+pt_c(fixed_c) = OK
+pt_r(fixed_c) = OK
+pt_c(fixed_r) = OK
+dense_r = OK
+dense_c = OK
+pt_r(dense_r) = OK
+pt_c(dense_c) = OK
+pt_r(dense_c) = OK
+pt_c(dense_r) = OK
+sparse_r = OK
+sparse_c = OK
+pt_r(sparse_r) = OK
+pt_c(sparse_c) = OK
+pt_r(sparse_c) = OK
+pt_c(sparse_r) = OK
diff --git a/example/example.cpp b/example/example.cpp
index 34b2df7..1f3c18d 100644
--- a/example/example.cpp
+++ b/example/example.cpp
@@ -25,8 +25,14 @@ void init_ex13(py::module &);
 void init_ex14(py::module &);
 void init_ex15(py::module &);
 void init_ex16(py::module &);
+void init_ex17(py::module &);
+void init_ex18(py::module &);
 void init_issues(py::module &);
 
+#if defined(PYBIND11_TEST_EIGEN)
+    void init_eigen(py::module &);
+#endif
+
 PYBIND11_PLUGIN(example) {
     py::module m("example", "pybind example plugin");
 
@@ -46,7 +52,13 @@ PYBIND11_PLUGIN(example) {
     init_ex14(m);
     init_ex15(m);
     init_ex16(m);
+    init_ex17(m);
+    init_ex18(m);
     init_issues(m);
 
+    #if defined(PYBIND11_TEST_EIGEN)
+        init_eigen(m);
+    #endif
+
     return m.ptr();
 }
diff --git a/example/example10.cpp b/example/example10.cpp
index 09769fe..06528c2 100644
--- a/example/example10.cpp
+++ b/example/example10.cpp
@@ -13,7 +13,7 @@
 
 double my_func(int x, float y, double z) {
     std::cout << "my_func(x:int=" << x << ", y:float=" << y << ", z:float=" << z << ")" << std::endl;
-    return x*y*z;
+    return (float) x*y*z;
 }
 
 std::complex<double> my_func3(std::complex<double> c) {
@@ -33,4 +33,9 @@ void init_ex10(py::module &m) {
 
     // Vectorize a complex-valued function
     m.def("vectorized_func3", py::vectorize(my_func3));
+
+    /// Numpy function which only accepts specific data types
+    m.def("selective_func", [](py::array_t<int, py::array::c_style>) { std::cout << "Int branch taken. "<< std::endl; });
+    m.def("selective_func", [](py::array_t<float, py::array::c_style>) { std::cout << "Float branch taken. "<< std::endl; });
+    m.def("selective_func", [](py::array_t<std::complex<float>, py::array::c_style>) { std::cout << "Complex float branch taken. "<< std::endl; });
 }
diff --git a/example/example10.py b/example/example10.py
index 0d49fca..b18e729 100755
--- a/example/example10.py
+++ b/example/example10.py
@@ -27,3 +27,8 @@ for f in [vectorized_func, vectorized_func2]:
     print(f(np.array([[1, 2, 3], [4, 5, 6]]), np.array([[2], [3]]), 2))
     print(np.array([[1, 2, 3], [4, 5, 6]])* np.array([[2], [3]])* 2)
 
+from example import selective_func
+
+selective_func(np.array([1], dtype=np.int32))
+selective_func(np.array([1.0], dtype=np.float32))
+selective_func(np.array([1.0j], dtype=np.complex64))
diff --git a/example/example10.ref b/example/example10.ref
index 9d48d7c..4885fc1 100644
--- a/example/example10.ref
+++ b/example/example10.ref
@@ -73,3 +73,6 @@ my_func(x:int=6, y:float=3, z:float=2)
  [ 24.  30.  36.]]
 [[ 4  8 12]
  [24 30 36]]
+Int branch taken. 
+Float branch taken. 
+Complex float branch taken. 
diff --git a/example/example11.cpp b/example/example11.cpp
index 1a472c9..4b3c6d0 100644
--- a/example/example11.cpp
+++ b/example/example11.cpp
@@ -19,6 +19,27 @@ void kw_func4(const std::vector<int> &entries) {
     std::cout << endl;
 }
 
+py::object call_kw_func(py::function f) {
+    py::tuple args = py::make_tuple(1234);
+    py::dict kwargs;
+    kwargs["y"] = py::cast(5678);
+    return f(*args, **kwargs);
+}
+
+void args_function(py::args args) {
+    for (size_t it=0; it<args.size(); ++it)
+        std::cout << "got argument: " << py::object(args[it]) << std::endl;
+}
+
+void args_kwargs_function(py::args args, py::kwargs kwargs) {
+    for (auto item : args)
+        std::cout << "got argument: " << item << std::endl;
+    if (kwargs) {
+        for (auto item : kwargs)
+            std::cout << "got keyword argument: " << item.first << " -> " << item.second << std::endl;
+    }
+}
+
 void init_ex11(py::module &m) {
     m.def("kw_func", &kw_func, py::arg("x"), py::arg("y"));
     m.def("kw_func2", &kw_func, py::arg("x") = 100, py::arg("y") = 200);
@@ -30,4 +51,12 @@ void init_ex11(py::module &m) {
     list.push_back(17);
 
     m.def("kw_func4", &kw_func4, py::arg("myList") = list);
+    m.def("call_kw_func", &call_kw_func);
+
+    m.def("args_function", &args_function);
+    m.def("args_kwargs_function", &args_kwargs_function);
+
+    using namespace py::literals;
+    m.def("kw_func_udl", &kw_func, "x"_a, "y"_a=300);
+    m.def("kw_func_udl_z", &kw_func, "x"_a, "y"_a=0);
 }
diff --git a/example/example11.py b/example/example11.py
index 04baa7b..09ba13e 100755
--- a/example/example11.py
+++ b/example/example11.py
@@ -5,12 +5,15 @@ import pydoc
 
 sys.path.append('.')
 
-from example import kw_func, kw_func2, kw_func3, kw_func4
+from example import kw_func, kw_func2, kw_func3, kw_func4, call_kw_func
+from example import args_function, args_kwargs_function, kw_func_udl, kw_func_udl_z
 
 print(pydoc.render_doc(kw_func, "Help on %s"))
 print(pydoc.render_doc(kw_func2, "Help on %s"))
 print(pydoc.render_doc(kw_func3, "Help on %s"))
 print(pydoc.render_doc(kw_func4, "Help on %s"))
+print(pydoc.render_doc(kw_func_udl, "Help on %s"))
+print(pydoc.render_doc(kw_func_udl_z, "Help on %s"))
 
 kw_func(5, 10)
 kw_func(5, y=10)
@@ -32,4 +35,12 @@ except Exception as e:
     print("Caught expected exception: " + str(e))
 
 kw_func4()
-kw_func4(myList = [1, 2, 3])
+kw_func4(myList=[1, 2, 3])
+
+call_kw_func(kw_func2)
+
+args_function('arg1_value', 'arg2_value', 3)
+args_kwargs_function('arg1_value', 'arg2_value', arg3='arg3_value', arg4=4)
+
+kw_func_udl(x=5, y=10)
+kw_func_udl_z(x=5)
diff --git a/example/example11.ref b/example/example11.ref
index 54e4fef..a693b6c 100644
--- a/example/example11.ref
+++ b/example/example11.ref
@@ -18,6 +18,16 @@ Help on built-in function kw_func4 in module example
 kkww__ffuunncc44(...)
     kw_func4(myList : list<int> = [13L, 17L]) -> NoneType
 
+Help on built-in function kw_func_udl in module example
+
+kkww__ffuunncc__uuddll(...)
+    kw_func_udl(x : int, y : int = 300L) -> NoneType
+
+Help on built-in function kw_func_udl_z in module example
+
+kkww__ffuunncc__uuddll__zz(...)
+    kw_func_udl_z(x : int, y : int = 0L) -> NoneType
+
 kw_func(x=5, y=10)
 kw_func(x=5, y=10)
 kw_func(x=5, y=10)
@@ -29,6 +39,17 @@ kw_func(x=5, y=10)
 kw_func(x=5, y=10)
 Caught expected exception: Incompatible function arguments. The following argument types are supported:
     1. (x : int = 100L, y : int = 200L) -> NoneType
-
+    Invoked with:
 kw_func4: 13 17 
 kw_func4: 1 2 3 
+kw_func(x=1234, y=5678)
+got argument: arg1_value
+got argument: arg2_value
+got argument: 3
+got argument: arg1_value
+got argument: arg2_value
+got keyword argument: arg3 -> arg3_value
+got keyword argument: arg4 -> 4
+
+kw_func(x=5, y=10)
+kw_func(x=5, y=0)
diff --git a/example/example12.cpp b/example/example12.cpp
index 84b1c35..e5555f5 100644
--- a/example/example12.cpp
+++ b/example/example12.cpp
@@ -56,7 +56,6 @@ public:
                           /* This function has no arguments. The trailing comma
                              in the previous line is needed for some compilers */
         );
-        throw std::runtime_error("this will never be reached");
     }
 
     virtual void pure_virtual() {
@@ -83,12 +82,10 @@ void runExample12Virtual(Example12 *ex) {
 }
 
 void init_ex12(py::module &m) {
-    /* Important: use the wrapper type as a template
-       argument to class_<>, but use the original name
-       to denote the type */
-    py::class_<PyExample12>(m, "Example12")
-        /* Declare that 'PyExample12' is really an alias for the original type 'Example12' */
-        .alias<Example12>()
+    /* Important: indicate the trampoline class PyExample12 using the third
+       argument to py::class_. The second argument with the unique pointer
+       is simply the default holder type used by pybind11. */
+    py::class_<Example12, std::unique_ptr<Example12>, PyExample12>(m, "Example12")
         .def(py::init<int>())
         /* Reference original class in function definitions */
         .def("run", &Example12::run)
diff --git a/example/example12.ref b/example/example12.ref
index 2274cdd..a25023f 100644
--- a/example/example12.ref
+++ b/example/example12.ref
@@ -1,7 +1,7 @@
 Constructing Example12..
 Original implementation of Example12::run(state=10, value=20)
 30
-Caught expected exception: Tried to call pure virtual function "pure_virtual"
+Caught expected exception: Tried to call pure virtual function "Example12::pure_virtual"
 Constructing Example12..
 ExtendedExample12::run(20), calling parent..
 Original implementation of Example12::run(state=11, value=21)
diff --git a/example/example14.ref b/example/example14.ref
index c18c7ad..44e6820 100644
--- a/example/example14.ref
+++ b/example/example14.ref
@@ -11,7 +11,7 @@ Got void ptr : 0x7f9ba0f3c430
 Called Example1 destructor (0)
 Caught expected exception: Incompatible function arguments. The following argument types are supported:
     1. (capsule) -> NoneType
-
+    Invoked with: [1, 2, 3]
 None
 Got null str : 0x0
 <example.StringList object at 0x10d3277a0>
diff --git a/example/example15.py b/example/example15.py
index 9868b62..1810d3e 100644
--- a/example/example15.py
+++ b/example/example15.py
@@ -14,7 +14,7 @@ p = Pickleable("test_value")
 p.setExtra1(15)
 p.setExtra2(48)
 
-data = pickle.dumps(p, -1)  # -1 is important (use highest protocol version)
+data = pickle.dumps(p, 2)  # Must use pickle protocol >= 2
 print("%s %i %i" % (p.value(), p.extra1(), p.extra2()))
 
 p2 = pickle.loads(data)
diff --git a/example/example17.cpp b/example/example17.cpp
new file mode 100644
index 0000000..8fd4ad6
--- /dev/null
+++ b/example/example17.cpp
@@ -0,0 +1,37 @@
+/*
+    example/example17.cpp -- Usage of stl_binders functions
+
+    Copyright (c) 2016 Sergey Lyskov
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#include "example.h"
+
+#include <pybind11/stl_bind.h>
+
+class El {
+public:
+	El() = delete;
+	El(int v) : a(v) { }
+
+	int a;
+};
+
+std::ostream & operator<<(std::ostream &s, El const&v) {
+	s << "El{" << v.a << '}';
+	return s;
+}
+
+void init_ex17(py::module &m) {
+	pybind11::class_<El>(m, "El")
+		.def(pybind11::init<int>());
+
+	pybind11::bind_vector<unsigned int>(m, "VectorInt");
+	pybind11::bind_vector<bool>(m, "VectorBool");
+
+	pybind11::bind_vector<El>(m, "VectorEl");
+
+    pybind11::bind_vector<std::vector<El>>(m, "VectorVectorEl");
+}
diff --git a/example/example17.py b/example/example17.py
new file mode 100644
index 0000000..feae307
--- /dev/null
+++ b/example/example17.py
@@ -0,0 +1,48 @@
+#!/usr/bin/env python
+from __future__ import print_function
+
+from example import VectorInt, El, VectorEl, VectorVectorEl, VectorBool
+
+v_int = VectorInt([0, 0])
+print(len(v_int))
+
+print(bool(v_int))
+
+v_int2 = VectorInt([0, 0])
+print(v_int == v_int2)
+
+v_int2[1] = 1
+print(v_int != v_int2)
+
+v_int2.append(2)
+v_int2.append(3)
+v_int2.insert(0, 1)
+v_int2.insert(0, 2)
+v_int2.insert(0, 3)
+print(v_int2)
+
+v_int.append(99)
+v_int2[2:-2] = v_int
+print(v_int2)
+del v_int2[1:3]
+print(v_int2)
+del v_int2[0]
+print(v_int2)
+
+v_a = VectorEl()
+v_a.append(El(1))
+v_a.append(El(2))
+print(v_a)
+
+vv_a = VectorVectorEl()
+vv_a.append(v_a)
+vv_b = vv_a[0]
+print(vv_b)
+
+vv_c = VectorBool()
+for i in range(10):
+    vv_c.append(i % 2 == 0)
+for i in range(10):
+    if vv_c[i] != (i % 2 == 0):
+        print("Error!")
+print(vv_c)
diff --git a/example/example17.ref b/example/example17.ref
new file mode 100644
index 0000000..cc271f3
--- /dev/null
+++ b/example/example17.ref
@@ -0,0 +1,11 @@
+2
+True
+True
+True
+VectorInt[3, 2, 1, 0, 1, 2, 3]
+VectorInt[3, 2, 0, 0, 99, 2, 3]
+VectorInt[3, 0, 99, 2, 3]
+VectorInt[0, 99, 2, 3]
+VectorEl[El{1}, El{2}]
+VectorEl[El{1}, El{2}]
+VectorBool[1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
diff --git a/example/example18.cpp b/example/example18.cpp
new file mode 100644
index 0000000..5a90202
--- /dev/null
+++ b/example/example18.cpp
@@ -0,0 +1,118 @@
+/*
+    example/example9.cpp -- exception translation
+
+    Copyright (c) 2016 Pim Schellart <P.Schellart@princeton.edu
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#include "example.h"
+#include <pybind11/exception_translator.h>
+
+// A type that should be raised as an exeption in Python
+class MyError : public std::exception {
+public:
+    explicit MyError(const char * m) : message{m} {}
+    virtual const char * what() const noexcept override {return message.c_str();}
+private:
+    std::string message = "";
+};
+
+// A type that should be translated to a standard Python exception
+class MyError2 : public std::exception {
+public:
+    explicit MyError2(const char * m) : message{m} {}
+    virtual const char * what() const noexcept override {return message.c_str();}
+private:
+    std::string message = "";
+};
+
+// A type that is not derived from std::exception (and is thus unknown)
+class MyError3 {
+public:
+    explicit MyError3(const char * m) : message{m} {}
+    virtual const char * what() const noexcept {return message.c_str();}
+private:
+    std::string message = "";
+};
+
+// A type that should be translated to MyError1
+// and delegated to its exception translator
+class MyError4 : public std::exception {
+public:
+    explicit MyError4(const char * m) : message{m} {}
+    virtual const char * what() const noexcept override {return message.c_str();}
+private:
+    std::string message = "";
+};
+
+void something_that_throws1() {
+    throw MyError("this error should go to a custom type");
+}
+
+void something_that_throws2() {
+    throw MyError2("this error should go to a standard Python exception");
+}
+
+void something_that_throws3() {
+    throw MyError3("this error cannot be translated");
+}
+
+void something_that_throws4() {
+    throw MyError4("this error is rethrown");
+}
+
+void something_that_throws5() {
+    throw std::logic_error("this error should fall through to the standard handler");
+}
+
+void init_ex18(py::module &m) {
+    py::class_<MyError> cls(m, "MyError");
+
+    cls.def(py::init<const char *>())
+        .def("what", &MyError::what)
+        .def("__repr__", &MyError::what);
+
+    // store custom exception type MyError and register new translator
+    static auto my_exception_type = cls.ptr();
+    py::register_exception_translator([](std::exception_ptr p) {
+        try {
+            if (p) std::rethrow_exception(p);
+        } catch (const MyError &e) {
+            // store current exception to ensure proper cleanup
+            static py::object current_exception;
+            current_exception = py::cast(MyError(e.what()));
+            PyErr_SetObject(my_exception_type, current_exception.ptr()); 
+        }
+    });
+
+    // register new translator for MyError2
+    // no need to store anything here because this type will
+    // never by visible from Python
+    py::register_exception_translator([](std::exception_ptr p) {
+        try {
+            if (p) std::rethrow_exception(p);
+        } catch (const MyError2 &e) {
+            PyErr_SetString(PyExc_RuntimeError, e.what());
+        }
+    });
+
+    // register new translator for MyError4
+    // which will catch it and delegate to the previously registered
+    // translator for MyError1 by throwing a new exception
+    py::register_exception_translator([](std::exception_ptr p) {
+        try {
+            if (p) std::rethrow_exception(p);
+        } catch (const MyError4 &e) {
+            throw MyError(e.what());
+        }
+    });
+
+    m.def("something_that_throws1", &something_that_throws1);
+    m.def("something_that_throws2", &something_that_throws2);
+    m.def("something_that_throws3", &something_that_throws3);
+    m.def("something_that_throws4", &something_that_throws4);
+    m.def("something_that_throws5", &something_that_throws5);
+}
+
diff --git a/example/example18.py b/example/example18.py
new file mode 100644
index 0000000..515fa43
--- /dev/null
+++ b/example/example18.py
@@ -0,0 +1,31 @@
+#!/usr/bin/env python
+from __future__ import print_function
+import sys
+sys.path.append('.')
+
+import example
+
+try:
+    example.something_that_throws1()
+except example.MyError as e:
+    print(type(e), e)
+
+try:
+    example.something_that_throws2()
+except Exception as e:
+    print(type(e), e)
+
+try:
+    example.something_that_throws3()
+except Exception as e:
+    print(type(e), e)
+
+try:
+    example.something_that_throws4()
+except example.MyError as e:
+    print(type(e), e)
+
+try:
+    example.something_that_throws5()
+except Exception as e:
+    print(type(e), e)
diff --git a/example/example18.ref b/example/example18.ref
new file mode 100644
index 0000000..ff6c9ad
--- /dev/null
+++ b/example/example18.ref
@@ -0,0 +1,5 @@
+<class 'example.MyError'> this error should go to a custom type
+<type 'exceptions.RuntimeError'> this error should go to a standard Python exception
+<type 'exceptions.RuntimeError'> Caught an unknown exception!
+<class 'example.MyError'> this error is rethrown
+<type 'exceptions.RuntimeError'> this error should fall through to the standard handler
diff --git a/example/example2.cpp b/example/example2.cpp
index 9b91baa..4b15823 100644
--- a/example/example2.cpp
+++ b/example/example2.cpp
@@ -154,7 +154,7 @@ void init_ex2(py::module &m) {
         .def("get_list", &Example2::get_list, "Return a Python list")
         .def("get_list_2", &Example2::get_list_2, "Return a C++ list")
         .def("get_set", &Example2::get_set, "Return a Python set")
-        .def("get_set2", &Example2::get_set, "Return a C++ set")
+        .def("get_set2", &Example2::get_set_2, "Return a C++ set")
         .def("get_array", &Example2::get_array, "Return a C++ array")
         .def("print_dict", &Example2::print_dict, "Print entries of a Python dictionary")
         .def("print_dict_2", &Example2::print_dict_2, "Print entries of a C++ dictionary")
diff --git a/example/example4.cpp b/example/example4.cpp
index 281eafe..7e17864 100644
--- a/example/example4.cpp
+++ b/example/example4.cpp
@@ -38,7 +38,7 @@ void test_function2(EMyEnumeration k) {
 
 float test_function3(int i) {
     std::cout << "test_function(" << i << ")" << std::endl;
-    return i / 2.f;
+    return (float) i / 2.f;
 }
 
 py::bytes return_bytes() {
diff --git a/example/example5.cpp b/example/example5.cpp
index 4ba6a34..11d37d0 100644
--- a/example/example5.cpp
+++ b/example/example5.cpp
@@ -43,12 +43,12 @@ void dog_bark(const Dog &dog) {
 }
 
 bool test_callback1(py::object func) {
-    func.call();
+    func();
     return false;
 }
 
 int test_callback2(py::object func) {
-    py::object result = func.call("Hello", 'x', true, 5);
+    py::object result = func("Hello", 'x', true, 5);
     return result.cast<int>();
 }
 
diff --git a/example/example5.ref b/example/example5.ref
index bfc3cb2..a9c7d46 100644
--- a/example/example5.ref
+++ b/example/example5.ref
@@ -14,7 +14,7 @@ Polly is a parrot
 Molly is a dog
 The following error is expected: Incompatible function arguments. The following argument types are supported:
     1. (example.Dog) -> NoneType
-
+    Invoked with: <Pet object at 0>
 Callback function 1 called!
 False
 Callback function 2 called : Hello, x, True, 5
diff --git a/example/example6.cpp b/example/example6.cpp
index 26552b7..e0bfb9e 100644
--- a/example/example6.cpp
+++ b/example/example6.cpp
@@ -133,22 +133,22 @@ void init_ex6(py::module &m) {
        .def("__reversed__", [](const Sequence &s) -> Sequence { return s.reversed(); })
        /// Slicing protocol (optional)
        .def("__getitem__", [](const Sequence &s, py::slice slice) -> Sequence* {
-            py::ssize_t start, stop, step, slicelength;
+            size_t start, stop, step, slicelength;
             if (!slice.compute(s.size(), &start, &stop, &step, &slicelength))
                 throw py::error_already_set();
             Sequence *seq = new Sequence(slicelength);
-            for (int i=0; i<slicelength; ++i) {
+            for (size_t i=0; i<slicelength; ++i) {
                 (*seq)[i] = s[start]; start += step;
             }
             return seq;
         })
        .def("__setitem__", [](Sequence &s, py::slice slice, const Sequence &value) {
-            py::ssize_t start, stop, step, slicelength;
+            size_t start, stop, step, slicelength;
             if (!slice.compute(s.size(), &start, &stop, &step, &slicelength))
                 throw py::error_already_set();
-            if ((size_t) slicelength != value.size())
+            if (slicelength != value.size())
                 throw std::runtime_error("Left and right hand size of slice assignment have different sizes!");
-            for (int i=0; i<slicelength; ++i) {
+            for (size_t i=0; i<slicelength; ++i) {
                 s[start] = value[i]; start += step;
             }
         })
diff --git a/example/example7.cpp b/example/example7.cpp
index 415b097..6aabf1c 100644
--- a/example/example7.cpp
+++ b/example/example7.cpp
@@ -80,7 +80,7 @@ void init_ex7(py::module &m) {
         /// Construct from a buffer
         .def("__init__", [](Matrix &v, py::buffer b) {
             py::buffer_info info = b.request();
-            if (info.format != py::format_descriptor<float>::value() || info.ndim != 2)
+            if (info.format != py::format_descriptor<float>::value || info.ndim != 2)
                 throw std::runtime_error("Incompatible buffer format!");
             new (&v) Matrix(info.shape[0], info.shape[1]);
             memcpy(v.data(), info.ptr, sizeof(float) * v.rows() * v.cols());
@@ -103,12 +103,12 @@ void init_ex7(py::module &m) {
        /// Provide buffer access
        .def_buffer([](Matrix &m) -> py::buffer_info {
             return py::buffer_info(
-                m.data(),                              /* Pointer to buffer */
-                sizeof(float),                         /* Size of one scalar */
-                py::format_descriptor<float>::value(), /* Python struct-style format descriptor */
-                2,                                     /* Number of dimensions */
-                { m.rows(), m.cols() },                /* Buffer dimensions */
-                { sizeof(float) * m.rows(),            /* Strides (in bytes) for each index */
+                m.data(),                            /* Pointer to buffer */
+                sizeof(float),                       /* Size of one scalar */
+                py::format_descriptor<float>::value, /* Python struct-style format descriptor */
+                2,                                   /* Number of dimensions */
+                { m.rows(), m.cols() },              /* Buffer dimensions */
+                { sizeof(float) * m.rows(),          /* Strides (in bytes) for each index */
                   sizeof(float) }
             );
         });
diff --git a/example/issues.cpp b/example/issues.cpp
index 1fa4d57..d75da1c 100644
--- a/example/issues.cpp
+++ b/example/issues.cpp
@@ -10,23 +10,21 @@
 #include "example.h"
 #include <pybind11/stl.h>
 
-struct Base {
-    virtual void dispatch(void) const = 0;
-};
-
-struct DispatchIssue : Base {
-    virtual void dispatch(void) const {
-        PYBIND11_OVERLOAD_PURE(void, Base, dispatch, /* no arguments */);
-    }
-};
-
-struct Placeholder { int i; Placeholder(int i) : i(i) { } };
-
-void dispatch_issue_go(const Base * b) { b->dispatch(); }
+PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>);
 
 void init_issues(py::module &m) {
     py::module m2 = m.def_submodule("issues");
 
+#if !defined(_MSC_VER)
+    // Visual Studio 2015 currently cannot compile this test
+    // (see the comment in type_caster_base::make_copy_constructor)
+    // #70 compilation issue if operator new is not public
+    class NonConstructible { private: void *operator new(size_t bytes) throw(); };
+    py::class_<NonConstructible>(m, "Foo");
+    m2.def("getstmt", []() -> NonConstructible * { return nullptr; },
+        py::return_value_policy::reference);
+#endif
+
     // #137: const char* isn't handled properly
     m2.def("print_cchar", [](const char *string) { std::cout << string << std::endl; });
 
@@ -34,12 +32,23 @@ void init_issues(py::module &m) {
     m2.def("print_char", [](char c) { std::cout << c << std::endl; });
 
     // #159: virtual function dispatch has problems with similar-named functions
-    py::class_<DispatchIssue> base(m2, "DispatchIssue");
-    base.alias<Base>()
+    struct Base { virtual void dispatch(void) const {
+        /* for some reason MSVC2015 can't compile this if the function is pure virtual */
+    }; };
+
+    struct DispatchIssue : Base {
+        virtual void dispatch(void) const {
+            PYBIND11_OVERLOAD_PURE(void, Base, dispatch, /* no arguments */);
+        }
+    };
+
+    py::class_<Base, std::unique_ptr<Base>, DispatchIssue>(m2, "DispatchIssue")
         .def(py::init<>())
         .def("dispatch", &Base::dispatch);
 
-    m2.def("dispatch_issue_go", &dispatch_issue_go);
+    m2.def("dispatch_issue_go", [](const Base * b) { b->dispatch(); });
+
+    struct Placeholder { int i; Placeholder(int i) : i(i) { } };
 
     py::class_<Placeholder>(m2, "Placeholder")
         .def(py::init<int>())
@@ -62,4 +71,71 @@ void init_issues(py::module &m) {
     m2.def("iterator_passthrough", [](py::iterator s) -> py::iterator {
         return py::make_iterator(std::begin(s), std::end(s));
     });
+
+    // #187: issue involving std::shared_ptr<> return value policy & garbage collection
+    struct ElementBase { virtual void foo() { } /* Force creation of virtual table */ };
+    struct ElementA : ElementBase {
+        ElementA(int v) : v(v) { }
+        int value() { return v; }
+        int v;
+    };
+
+    struct ElementList {
+        void add(std::shared_ptr<ElementBase> e) { l.push_back(e); }
+        std::vector<std::shared_ptr<ElementBase>> l;
+    };
+
+    py::class_<ElementBase, std::shared_ptr<ElementBase>> (m2, "ElementBase");
+
+    py::class_<ElementA, std::shared_ptr<ElementA>>(m2, "ElementA", py::base<ElementBase>())
+        .def(py::init<int>())
+        .def("value", &ElementA::value);
+
+    py::class_<ElementList, std::shared_ptr<ElementList>>(m2, "ElementList")
+        .def(py::init<>())
+        .def("add", &ElementList::add)
+        .def("get", [](ElementList &el){
+            py::list list;
+            for (auto &e : el.l)
+                list.append(py::cast(e));
+            return list;
+        });
+
+    // (no id): should not be able to pass 'None' to a reference argument
+    m2.def("print_element", [](ElementA &el) { std::cout << el.value() << std::endl; });
+
+    // (no id): don't cast doubles to ints
+    m2.def("expect_float", [](float f) { return f; });
+    m2.def("expect_int", [](int i) { return i; });
+
+    // (no id): don't invoke Python dispatch code when instantiating C++
+    // classes that were not extended on the Python side
+    struct A {
+        virtual ~A() {}
+        virtual void f() { std::cout << "A.f()" << std::endl; }
+    };
+
+    struct PyA : A {
+        PyA() { std::cout << "PyA.PyA()" << std::endl; }
+
+        void f() override {
+            std::cout << "PyA.f()" << std::endl;
+            PYBIND11_OVERLOAD(void, A, f);
+        }
+    };
+
+    auto call_f = [](A *a) { a->f(); };
+
+	pybind11::class_<A, std::unique_ptr<A>, PyA>(m2, "A")
+	    .def(py::init<>())
+	    .def("f", &A::f);
+
+	 m2.def("call_f", call_f);
+
+    try {
+        py::class_<Placeholder>(m2, "Placeholder");
+        throw std::logic_error("Expected an exception!");
+    } catch (std::runtime_error &) {
+        /* All good */
+    }
 }
diff --git a/example/issues.py b/example/issues.py
index be241e1..257f08e 100644
--- a/example/issues.py
+++ b/example/issues.py
@@ -5,8 +5,12 @@ sys.path.append('.')
 
 from example.issues import print_cchar, print_char
 from example.issues import DispatchIssue, dispatch_issue_go
-from example.issues import Placeholder ,return_vec_of_reference_wrapper
+from example.issues import Placeholder, return_vec_of_reference_wrapper
 from example.issues import iterator_passthrough
+from example.issues import ElementList, ElementA, print_element
+from example.issues import expect_float, expect_int
+from example.issues import A, call_f
+import gc
 
 print_cchar("const char *")
 print_char('c')
@@ -32,3 +36,39 @@ dispatch_issue_go(b)
 print(return_vec_of_reference_wrapper(Placeholder(4)))
 
 print(list(iterator_passthrough(iter([3, 5, 7, 9, 11, 13, 15]))))
+
+el = ElementList()
+for i in range(10):
+    el.add(ElementA(i))
+gc.collect()
+for i, v in enumerate(el.get()):
+    print("%i==%i, " % (i, v.value()), end='')
+print()
+
+try:
+    print_element(None)
+except Exception as e:
+    print("Failed as expected: " + str(e))
+
+try:
+    print(expect_int(5.2))
+except Exception as e:
+    print("Failed as expected: " + str(e))
+
+print(expect_float(12))
+
+class B(A):
+    def __init__(self):
+        super(B, self).__init__()
+
+    def f(self):
+        print("In python f()")
+
+print("C++ version")
+a = A()
+call_f(a)
+
+print("Python version")
+b = B()
+call_f(b)
+
diff --git a/example/issues.ref b/example/issues.ref
index 6d9a893..58cc798 100644
--- a/example/issues.ref
+++ b/example/issues.ref
@@ -1,6 +1,20 @@
 const char *
 c
-Failed as expected: Tried to call pure virtual function "dispatch"
+Failed as expected: Tried to call pure virtual function "Base::dispatch"
 Yay..
 [Placeholder[1], Placeholder[2], Placeholder[3], Placeholder[4]]
 [3, 5, 7, 9, 11, 13, 15]
+0==0, 1==1, 2==2, 3==3, 4==4, 5==5, 6==6, 7==7, 8==8, 9==9, 
+Failed as expected: Incompatible function arguments. The following argument types are supported:
+    1. (example.issues.ElementA) -> NoneType
+    Invoked with: None
+Failed as expected: Incompatible function arguments. The following argument types are supported:
+    1. (int) -> int
+    Invoked with: 5.2
+12.0
+C++ version
+A.f()
+Python version
+PyA.PyA()
+PyA.f()
+In python f()
diff --git a/example/run_test.py b/example/run_test.py
index d0967c6..70ce4a6 100755
--- a/example/run_test.py
+++ b/example/run_test.py
@@ -2,6 +2,7 @@ import sys
 import os
 import re
 import subprocess
+import difflib
 
 remove_unicode_marker = re.compile(r'u(\'[^\']*\')')
 remove_long_marker    = re.compile(r'([0-9])L')
@@ -36,11 +37,7 @@ def sanitize(lines):
                 line = ""
         lines[i] = line
 
-    lines = '\n'.join(sorted([l for l in lines if l != ""]))
-
-    print('==================')
-    print(lines)
-    return lines
+    return '\n'.join(sorted([l for l in lines if l != ""]))
 
 path = os.path.dirname(__file__)
 if path != '':
@@ -69,4 +66,8 @@ elif output == reference:
     exit(0)
 else:
     print('Test "%s" FAILED!' % name)
+    print('--- output')
+    print('+++ reference')
+    print(''.join(difflib.ndiff(output.splitlines(keepends=True),
+                                reference.splitlines(keepends=True))))
     exit(-1)
diff --git a/include/pybind11/attr.h b/include/pybind11/attr.h
index 86face3..1e063a5 100644
--- a/include/pybind11/attr.h
+++ b/include/pybind11/attr.h
@@ -18,23 +18,29 @@ template <typename T> struct arg_t;
 
 /// Annotation for keyword arguments
 struct arg {
-    arg(const char *name) : name(name) { }
-    template <typename T> arg_t<T> operator=(const T &value);
-    template <typename T, size_t N> arg_t<const T *> operator=(T const (&value)[N]);
+    constexpr explicit arg(const char *name) : name(name) { }
+
+    template <typename T>
+    constexpr arg_t<T> operator=(const T &value) const { return {name, value}; }
+    template <typename T, size_t N>
+    constexpr arg_t<const T *> operator=(T const (&value)[N]) const {
+        return operator=((const T *) value);
+    }
+
     const char *name;
 };
 
 /// Annotation for keyword arguments with default values
 template <typename T> struct arg_t : public arg {
-    arg_t(const char *name, const T &value, const char *descr = nullptr)
+    constexpr arg_t(const char *name, const T &value, const char *descr = nullptr)
         : arg(name), value(value), descr(descr) { }
     T value;
     const char *descr;
 };
 
-template <typename T> arg_t<T> arg::operator=(const T &value) { return arg_t<T>(name, value); }
-template <typename T, size_t N> arg_t<const T *> arg::operator=(T const (&value)[N]) {
-    return operator=((const T *) value);
+inline namespace literals {
+/// String literal version of arg
+constexpr arg operator"" _a(const char *name, size_t) { return arg(name); }
 }
 
 /// Annotation for methods
@@ -65,6 +71,7 @@ enum op_type : int;
 struct undefined_t;
 template <op_id id, op_type ot, typename L = undefined_t, typename R = undefined_t> struct op_;
 template <typename... Args> struct init;
+template <typename... Args> struct init_alias;
 inline void keep_alive_impl(int Nurse, int Patient, handle args, handle ret);
 
 /// Internal data structure which holds metadata about a keyword argument
@@ -92,19 +99,28 @@ struct function_record {
     std::vector<argument_record> args;
 
     /// Pointer to lambda function which converts arguments and performs the actual call
-    handle (*impl) (function_record *, handle, handle) = nullptr;
+    handle (*impl) (function_record *, handle, handle, handle) = nullptr;
 
     /// Storage for the wrapped function pointer and captured data, if any
-    void *data = nullptr;
+    void *data[3] = { };
 
     /// Pointer to custom destructor for 'data' (if needed)
-    void (*free_data) (void *ptr) = nullptr;
+    void (*free_data) (function_record *ptr) = nullptr;
 
     /// Return value policy associated with this function
     return_value_policy policy = return_value_policy::automatic;
 
     /// True if name == '__init__'
-    bool is_constructor = false;
+    bool is_constructor : 1;
+
+    /// True if the function has a '*args' argument
+    bool has_args : 1;
+
+    /// True if the function has a '**kwargs' argument
+    bool has_kwargs : 1;
+
+    /// Number of arguments
+    uint16_t nargs;
 
     /// Python method object
     PyMethodDef *def = nullptr;
@@ -305,5 +321,18 @@ template <typename... Args> struct process_attributes {
     }
 };
 
+/// Compile-time integer sum
+constexpr size_t constexpr_sum() { return 0; }
+template <typename T, typename... Ts>
+constexpr size_t constexpr_sum(T n, Ts... ns) { return n + constexpr_sum(ns...); }
+
+/// Check the number of named arguments at compile time
+template <typename... Extra,
+          size_t named = constexpr_sum(std::is_base_of<arg, Extra>::value...),
+          size_t self  = constexpr_sum(std::is_same<is_method, Extra>::value...)>
+constexpr bool expected_num_args(size_t nargs) {
+    return named == 0 || (self + named) == nargs;
+}
+
 NAMESPACE_END(detail)
 NAMESPACE_END(pybind11)
diff --git a/include/pybind11/cast.h b/include/pybind11/cast.h
index b5b3ae0..569fc81 100644
--- a/include/pybind11/cast.h
+++ b/include/pybind11/cast.h
@@ -15,6 +15,7 @@
 #include "descr.h"
 #include <array>
 #include <limits>
+#include <iostream>
 
 NAMESPACE_BEGIN(pybind11)
 NAMESPACE_BEGIN(detail)
@@ -29,6 +30,28 @@ struct type_info {
     void *get_buffer_data = nullptr;
 };
 
+struct default_exception_translator {
+    void operator()(std::exception_ptr p) {
+        try {
+            if (p) std::rethrow_exception(p);
+        } catch (const error_already_set &)      {                                                 return;
+        } catch (const index_error &e)           { PyErr_SetString(PyExc_IndexError,    e.what()); return;
+        } catch (const value_error &e)           { PyErr_SetString(PyExc_ValueError,    e.what()); return;
+        } catch (const stop_iteration &e)        { PyErr_SetString(PyExc_StopIteration, e.what()); return;
+        } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return;
+        } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;
+        } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return;
+        } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return;
+        } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return;
+        } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return;
+        } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return;
+        } catch (...) {
+            PyErr_SetString(PyExc_RuntimeError, "Caught an unknown exception!");
+            return;
+        }
+    }
+};
+
 PYBIND11_NOINLINE inline internals &get_internals() {
     static internals *internals_ptr = nullptr;
     if (internals_ptr)
@@ -48,6 +71,8 @@ PYBIND11_NOINLINE inline internals &get_internals() {
             internals_ptr->istate = tstate->interp;
         #endif
         builtins[id] = capsule(internals_ptr);
+        static default_exception_translator translator;
+        internals_ptr->registered_exception_translators.push_front(translator);
     }
     return *internals_ptr;
 }
@@ -247,22 +272,35 @@ public:
     static handle cast(const type *src, return_value_policy policy, handle parent) {
         return type_caster_generic::cast(
             src, policy, parent, src ? &typeid(*src) : nullptr, &typeid(type),
-            &copy_constructor, &move_constructor);
+            make_copy_constructor(src), make_move_constructor(src));
     }
 
     template <typename T> using cast_op_type = pybind11::detail::cast_op_type<T>;
 
     operator type*() { return (type *) value; }
-    operator type&() { return *((type *) value); }
+    operator type&() { if (!value) throw cast_error(); return *((type *) value); }
+
 protected:
-    template <typename T = type, typename std::enable_if<detail::is_copy_constructible<T>::value, int>::type = 0>
-    static void *copy_constructor(const void *arg) { return (void *) new type(*((const type *) arg)); }
-    template <typename T = type, typename std::enable_if<!detail::is_copy_constructible<T>::value, int>::type = 0>
-    static void *copy_constructor(const void *) { return nullptr; }
-    template <typename T = type, typename std::enable_if<detail::is_move_constructible<T>::value, int>::type = 0>
-    static void *move_constructor(const void *arg) { return (void *) new type(std::move(*((type *) arg))); }
-    template <typename T = type, typename std::enable_if<!detail::is_move_constructible<T>::value, int>::type = 0>
-    static void *move_constructor(const void *) { return nullptr; }
+    typedef void *(*Constructor)(const void *stream);
+#if !defined(_MSC_VER)
+    /* Only enabled when the types are {copy,move}-constructible *and* when the type
+       does not have a private operator new implementaton. */
+    template <typename T = type> static auto make_copy_constructor(const T *value) -> decltype(new T(*value), Constructor(nullptr)) {
+        return [](const void *arg) -> void * { return new T(*((const T *) arg)); }; }
+    template <typename T = type> static auto make_move_constructor(const T *value) -> decltype(new T(std::move(*((T *) value))), Constructor(nullptr)) {
+        return [](const void *arg) -> void * { return (void *) new T(std::move(*((T *) arg))); }; }
+#else
+    /* Visual Studio 2015's SFINAE implementation doesn't yet handle the above robustly in all situations.
+       Use a workaround that only tests for constructibility for now. */
+    template <typename T = type, typename = typename std::enable_if<std::is_copy_constructible<T>::value>::type>
+    static Constructor make_copy_constructor(const T *value) {
+        return [](const void *arg) -> void * { return new T(*((const T *)arg)); }; }
+    template <typename T = type, typename = typename std::enable_if<std::is_move_constructible<T>::value>::type>
+    static Constructor make_move_constructor(const T *value) {
+        return [](const void *arg) -> void * { return (void *) new T(std::move(*((T *)arg))); }; }
+#endif
+    static Constructor make_copy_constructor(...) { return nullptr; }
+    static Constructor make_move_constructor(...) { return nullptr; }
 };
 
 template <typename type, typename SFINAE = void> class type_caster : public type_caster_base<type> { };
@@ -307,14 +345,20 @@ public:
     bool load(handle src, bool) {
         py_type py_value;
 
-        if (std::is_floating_point<T>::value) {
+        if (!src) {
+            return false;
+        } if (std::is_floating_point<T>::value) {
             py_value = (py_type) PyFloat_AsDouble(src.ptr());
         } else if (sizeof(T) <= sizeof(long)) {
+            if (PyFloat_Check(src.ptr()))
+                return false;
             if (std::is_signed<T>::value)
                 py_value = (py_type) PyLong_AsLong(src.ptr());
             else
                 py_value = (py_type) PyLong_AsUnsignedLong(src.ptr());
         } else {
+            if (PyFloat_Check(src.ptr()))
+                return false;
             if (std::is_signed<T>::value)
                 py_value = (py_type) PYBIND11_LONG_AS_LONGLONG(src.ptr());
             else
@@ -381,7 +425,9 @@ public:
     using type_caster<void_type>::cast;
 
     bool load(handle h, bool) {
-        if (h.ptr() == Py_None) {
+        if (!h) {
+            return false;
+        } else if (h.ptr() == Py_None) {
             value = nullptr;
             return true;
         }
@@ -422,7 +468,8 @@ template <> class type_caster<std::nullptr_t> : public type_caster<void_type> {
 template <> class type_caster<bool> {
 public:
     bool load(handle src, bool) {
-        if (src.ptr() == Py_True) { value = true; return true; }
+        if (!src) return false;
+        else if (src.ptr() == Py_True) { value = true; return true; }
         else if (src.ptr() == Py_False) { value = false; return true; }
         else return false;
     }
@@ -437,7 +484,9 @@ public:
     bool load(handle src, bool) {
         object temp;
         handle load_src = src;
-        if (PyUnicode_Check(load_src.ptr())) {
+        if (!src) {
+            return false;
+        } else if (PyUnicode_Check(load_src.ptr())) {
             temp = object(PyUnicode_AsUTF8String(load_src.ptr()), false);
             if (!temp) { PyErr_Clear(); return false; }  // UnicodeEncodeError
             load_src = temp;
@@ -446,13 +495,13 @@ public:
         ssize_t length;
         int err = PYBIND11_BYTES_AS_STRING_AND_SIZE(load_src.ptr(), &buffer, &length);
         if (err == -1) { PyErr_Clear(); return false; }  // TypeError
-        value = std::string(buffer, length);
+        value = std::string(buffer, (size_t) length);
         success = true;
         return true;
     }
 
     static handle cast(const std::string &src, return_value_policy /* policy */, handle /* parent */) {
-        return PyUnicode_FromStringAndSize(src.c_str(), src.length());
+        return PyUnicode_FromStringAndSize(src.c_str(), (ssize_t) src.length());
     }
 
     PYBIND11_TYPE_CASTER(std::string, _(PYBIND11_STRING_NAME));
@@ -476,7 +525,9 @@ public:
     bool load(handle src, bool) {
         object temp;
         handle load_src = src;
-        if (!PyUnicode_Check(load_src.ptr())) {
+        if (!src) {
+            return false;
+        } else if (!PyUnicode_Check(load_src.ptr())) {
             temp = object(PyUnicode_FromObject(load_src.ptr()), false);
             if (!temp) { PyErr_Clear(); return false; }
             load_src = temp;
@@ -493,17 +544,17 @@ public:
         if (temp) {
             int err = PYBIND11_BYTES_AS_STRING_AND_SIZE(temp.ptr(), (char **) &buffer, &length);
             if (err == -1) { buffer = nullptr; }  // TypeError
-            length = length / sizeof(wchar_t) - 1; ++buffer; // Skip BOM
+            length = length / (ssize_t) sizeof(wchar_t) - 1; ++buffer; // Skip BOM
         }
 #endif
         if (!buffer) { PyErr_Clear(); return false; }
-        value = std::wstring(buffer, length);
+        value = std::wstring(buffer, (size_t) length);
         success = true;
         return true;
     }
 
     static handle cast(const std::wstring &src, return_value_policy /* policy */, handle /* parent */) {
-        return PyUnicode_FromWideChar(src.c_str(), src.length());
+        return PyUnicode_FromWideChar(src.c_str(), (ssize_t) src.length());
     }
 
     PYBIND11_TYPE_CASTER(std::wstring, _(PYBIND11_STRING_NAME));
@@ -514,7 +565,7 @@ protected:
 template <> class type_caster<char> : public type_caster<std::string> {
 public:
     bool load(handle src, bool convert) {
-        if (src.ptr() == Py_None) { return true; }
+        if (src.ptr() == Py_None) return true;
         return type_caster<std::string>::load(src, convert);
     }
 
@@ -537,13 +588,13 @@ public:
 template <> class type_caster<wchar_t> : public type_caster<std::wstring> {
 public:
     bool load(handle src, bool convert) {
-        if (src.ptr() == Py_None) { return true; }
+        if (src.ptr() == Py_None) return true;
         return type_caster<std::wstring>::load(src, convert);
     }
 
     static handle cast(const wchar_t *src, return_value_policy /* policy */, handle /* parent */) {
         if (src == nullptr) return handle(Py_None).inc_ref();
-        return PyUnicode_FromWideChar(src, wcslen(src));
+        return PyUnicode_FromWideChar(src, (ssize_t) wcslen(src));
     }
 
     static handle cast(wchar_t src, return_value_policy /* policy */, handle /* parent */) {
@@ -561,7 +612,9 @@ template <typename T1, typename T2> class type_caster<std::pair<T1, T2>> {
     typedef std::pair<T1, T2> type;
 public:
     bool load(handle src, bool convert) {
-        if (!PyTuple_Check(src.ptr()) || PyTuple_Size(src.ptr()) != 2)
+        if (!src)
+            return false;
+        else if (!PyTuple_Check(src.ptr()) || PyTuple_Size(src.ptr()) != 2)
             return false;
         return  first.load(PyTuple_GET_ITEM(src.ptr(), 0), convert) &&
                second.load(PyTuple_GET_ITEM(src.ptr(), 1), convert);
@@ -597,13 +650,41 @@ protected:
 
 template <typename... Tuple> class type_caster<std::tuple<Tuple...>> {
     typedef std::tuple<Tuple...> type;
+    typedef std::tuple<typename intrinsic_type<Tuple>::type...> itype;
+    typedef std::tuple<args> args_type;
+    typedef std::tuple<args, kwargs> args_kwargs_type;
 public:
     enum { size = sizeof...(Tuple) };
 
+    static constexpr const bool has_kwargs = std::is_same<itype, args_kwargs_type>::value;
+    static constexpr const bool has_args = has_kwargs || std::is_same<itype, args_type>::value;
+
     bool load(handle src, bool convert) {
+        if (!src || !PyTuple_Check(src.ptr()) || PyTuple_GET_SIZE(src.ptr()) != size)
+            return false;
         return load(src, convert, typename make_index_sequence<sizeof...(Tuple)>::type());
     }
 
+    template <typename T = itype, typename std::enable_if<
+        !std::is_same<T, args_type>::value &&
+        !std::is_same<T, args_kwargs_type>::value, int>::type = 0>
+    bool load_args(handle args, handle, bool convert) {
+        return load(args, convert, typename make_index_sequence<sizeof...(Tuple)>::type());
+    }
+
+    template <typename T = itype, typename std::enable_if<std::is_same<T, args_type>::value, int>::type = 0>
+    bool load_args(handle args, handle, bool convert) {
+        std::get<0>(value).load(args, convert);
+        return true;
+    }
+
+    template <typename T = itype, typename std::enable_if<std::is_same<T, args_kwargs_type>::value, int>::type = 0>
+    bool load_args(handle args, handle kwargs, bool convert) {
+        std::get<0>(value).load(args, convert);
+        std::get<1>(value).load(kwargs, convert);
+        return true;
+    }
+
     static handle cast(const type &src, return_value_policy policy, handle parent) {
         return cast(src, policy, parent, typename make_index_sequence<size>::type());
     }
@@ -642,10 +723,8 @@ protected:
     }
 
     template <size_t ... Indices> bool load(handle src, bool convert, index_sequence<Indices...>) {
-        if (!PyTuple_Check(src.ptr()) || PyTuple_Size(src.ptr()) != size)
-            return false;
         std::array<bool, size> success {{
-            (PyTuple_GET_ITEM(src.ptr(), Indices) != nullptr ? std::get<Indices>(value).load(PyTuple_GET_ITEM(src.ptr(), Indices), convert) : false)...
+            std::get<Indices>(value).load(PyTuple_GET_ITEM(src.ptr(), Indices), convert)...
         }};
         (void) convert; /* avoid a warning when the tuple is empty */
         for (bool r : success)
@@ -680,8 +759,6 @@ public:
     using type_caster_base<type>::typeinfo;
     using type_caster_base<type>::value;
     using type_caster_base<type>::temp;
-    using type_caster_base<type>::copy_constructor;
-    using type_caster_base<type>::move_constructor;
 
     bool load(handle src, bool convert) {
         if (!src || !typeinfo) {
@@ -718,11 +795,11 @@ public:
     explicit operator holder_type&() { return holder; }
     #endif
 
-    static handle cast(const holder_type &src, return_value_policy policy, handle parent) {
+    static handle cast(const holder_type &src, return_value_policy, handle) {
         return type_caster_generic::cast(
-            src.get(), policy, parent,
+            src.get(), return_value_policy::take_ownership, handle(),
             src.get() ? &typeid(*src.get()) : nullptr, &typeid(type),
-            &copy_constructor, &move_constructor, &src);
+            nullptr, nullptr, &src);
     }
 
 protected:
@@ -731,14 +808,16 @@ protected:
 
 template <typename T> struct handle_type_name { static PYBIND11_DESCR name() { return _<T>(); } };
 template <> struct handle_type_name<bytes> { static PYBIND11_DESCR name() { return _(PYBIND11_BYTES_NAME); } };
+template <> struct handle_type_name<args> { static PYBIND11_DESCR name() { return _("*args"); } };
+template <> struct handle_type_name<kwargs> { static PYBIND11_DESCR name() { return _("**kwargs"); } };
 
 template <typename type>
 struct type_caster<type, typename std::enable_if<std::is_base_of<handle, type>::value>::type> {
 public:
-    template <typename T = type, typename std::enable_if<std::is_same<T, handle>::value, int>::type = 0>
-    bool load(handle src, bool /* convert */) { value = src; return value.check(); }
+    template <typename T = type, typename std::enable_if<!std::is_base_of<object, T>::value, int>::type = 0>
+    bool load(handle src, bool /* convert */) { value = type(src); return value.check(); }
 
-    template <typename T = type, typename std::enable_if<!std::is_same<T, handle>::value, int>::type = 0>
+    template <typename T = type, typename std::enable_if<std::is_base_of<object, T>::value, int>::type = 0>
     bool load(handle src, bool /* convert */) { value = type(src, true); return value.check(); }
 
     static handle cast(const handle &src, return_value_policy /* policy */, handle /* parent */) {
@@ -749,14 +828,17 @@ public:
 
 NAMESPACE_END(detail)
 
-template <typename T> inline T cast(handle handle) {
-    detail::type_caster<typename detail::intrinsic_type<T>::type> conv;
+template <typename T> T cast(handle handle) {
+    typedef detail::type_caster<typename detail::intrinsic_type<T>::type> type_caster;
+    type_caster conv;
     if (!conv.load(handle, true))
         throw cast_error("Unable to cast Python object to C++ type");
-    return (T) conv;
+    return conv.operator typename type_caster::template cast_op_type<T>();
 }
 
-template <typename T> inline object cast(const T &value, return_value_policy policy = return_value_policy::automatic_reference, handle parent = handle()) {
+template <typename T> object cast(const T &value,
+        return_value_policy policy = return_value_policy::automatic_reference,
+        handle parent = handle()) {
     if (policy == return_value_policy::automatic)
         policy = std::is_pointer<T>::value ? return_value_policy::take_ownership : return_value_policy::copy;
     else if (policy == return_value_policy::automatic_reference)
@@ -764,11 +846,11 @@ template <typename T> inline object cast(const T &value, return_value_policy pol
     return object(detail::type_caster<typename detail::intrinsic_type<T>::type>::cast(value, policy, parent), false);
 }
 
-template <typename T> inline T handle::cast() const { return pybind11::cast<T>(*this); }
+template <typename T> T handle::cast() const { return pybind11::cast<T>(*this); }
 template <> inline void handle::cast() const { return; }
 
 template <return_value_policy policy = return_value_policy::automatic_reference,
-          typename... Args> inline tuple make_tuple(Args&&... args_) {
+          typename... Args> tuple make_tuple(Args&&... args_) {
     const size_t size = sizeof...(Args);
     std::array<object, size> args {
         { object(detail::type_caster<typename detail::intrinsic_type<Args>::type>::cast(
@@ -784,7 +866,7 @@ template <return_value_policy policy = return_value_policy::automatic_reference,
     return result;
 }
 
-template <typename... Args> inline object handle::call(Args&&... args) const {
+template <typename... Args> object handle::operator()(Args&&... args) const {
     tuple args_tuple = pybind11::make_tuple(std::forward<Args>(args)...);
     object result(PyObject_CallObject(m_ptr, args_tuple.ptr()), false);
     if (!result)
@@ -792,6 +874,24 @@ template <typename... Args> inline object handle::call(Args&&... args) const {
     return result;
 }
 
+template <typename... Args> object handle::call(Args &&... args) const {
+    return operator()(std::forward<Args>(args)...);
+}
+
+inline object handle::operator()(detail::args_proxy args) const {
+    object result(PyObject_CallObject(m_ptr, args.ptr()), false);
+    if (!result)
+        throw error_already_set();
+    return result;
+}
+
+inline object handle::operator()(detail::args_proxy args, detail::kwargs_proxy kwargs) const {
+    object result(PyObject_Call(m_ptr, args.ptr(), kwargs.ptr()), false);
+    if (!result)
+        throw error_already_set();
+    return result;
+}
+
 #define PYBIND11_MAKE_OPAQUE(Type) \
     namespace pybind11 { namespace detail { \
         template<> class type_caster<Type> : public type_caster_base<Type> { }; \
diff --git a/include/pybind11/common.h b/include/pybind11/common.h
index 4c059b8..db2d398 100644
--- a/include/pybind11/common.h
+++ b/include/pybind11/common.h
@@ -31,7 +31,7 @@
 #endif
 
 #define PYBIND11_VERSION_MAJOR 1
-#define PYBIND11_VERSION_MINOR 7
+#define PYBIND11_VERSION_MINOR 9
 
 /// Include Python header, disable linking to pythonX_d.lib on Windows in debug mode
 #if defined(_MSC_VER)
@@ -66,6 +66,7 @@
 #  pragma warning(pop)
 #endif
 
+#include <forward_list>
 #include <vector>
 #include <string>
 #include <stdexcept>
@@ -81,6 +82,7 @@
 #define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyBytes_FromStringAndSize
 #define PYBIND11_BYTES_AS_STRING_AND_SIZE PyBytes_AsStringAndSize
 #define PYBIND11_BYTES_AS_STRING PyBytes_AsString
+#define PYBIND11_BYTES_CHECK PyBytes_Check
 #define PYBIND11_LONG_CHECK(o) PyLong_Check(o)
 #define PYBIND11_LONG_AS_LONGLONG(o) PyLong_AsLongLong(o)
 #define PYBIND11_LONG_AS_UNSIGNED_LONGLONG(o) PyLong_AsUnsignedLongLong(o)
@@ -98,6 +100,7 @@
 #define PYBIND11_BYTES_FROM_STRING_AND_SIZE PyString_FromStringAndSize
 #define PYBIND11_BYTES_AS_STRING_AND_SIZE PyString_AsStringAndSize
 #define PYBIND11_BYTES_AS_STRING PyString_AsString
+#define PYBIND11_BYTES_CHECK PyString_Check
 #define PYBIND11_LONG_CHECK(o) (PyInt_Check(o) || PyLong_Check(o))
 #define PYBIND11_LONG_AS_LONGLONG(o) (PyInt_Check(o) ? (long long) PyLong_AsLong(o) : PyLong_AsLongLong(o))
 #define PYBIND11_LONG_AS_UNSIGNED_LONGLONG(o) (PyInt_Check(o) ? (unsigned long long) PyLong_AsUnsignedLong(o) : PyLong_AsUnsignedLongLong(o))
@@ -140,7 +143,7 @@ NAMESPACE_BEGIN(pybind11)
 typedef Py_ssize_t ssize_t;
 
 /// Approach used to cast a previously unknown C++ instance into a Python object
-enum class return_value_policy : int {
+enum class return_value_policy : uint8_t {
     /** This is the default return value policy, which falls back to the policy
         return_value_policy::take_ownership when the return value is a pointer.
         Otherwise, it uses return_value::move or return_value::copy for rvalue
@@ -189,34 +192,29 @@ enum class return_value_policy : int {
     reference_internal
 };
 
-/// Format strings for basic number types
-template <typename type> struct format_descriptor { };
-#define PYBIND11_DECL_FMT(t, n) template<> struct format_descriptor<t> { static std::string value() { return n; }; }
-PYBIND11_DECL_FMT(int8_t,  "b"); PYBIND11_DECL_FMT(uint8_t,  "B"); PYBIND11_DECL_FMT(int16_t, "h"); PYBIND11_DECL_FMT(uint16_t, "H");
-PYBIND11_DECL_FMT(int32_t, "i"); PYBIND11_DECL_FMT(uint32_t, "I"); PYBIND11_DECL_FMT(int64_t, "q"); PYBIND11_DECL_FMT(uint64_t, "Q");
-PYBIND11_DECL_FMT(float,   "f"); PYBIND11_DECL_FMT(double,   "d"); PYBIND11_DECL_FMT(bool,    "?");
-
 /// Information record describing a Python buffer object
 struct buffer_info {
     void *ptr;                   // Pointer to the underlying storage
     size_t itemsize;             // Size of individual items in bytes
     size_t size;                 // Total number of entries
     std::string format;          // For homogeneous buffers, this should be set to format_descriptor<T>::value
-    int ndim;                    // Number of dimensions
+    size_t ndim;                 // Number of dimensions
     std::vector<size_t> shape;   // Shape of the tensor (1 entry per dimension)
     std::vector<size_t> strides; // Number of entries between adjacent entries (for each per dimension)
 
-    buffer_info(void *ptr, size_t itemsize, const std::string &format, int ndim,
+    buffer_info() : ptr(nullptr), view(nullptr) {}
+    buffer_info(void *ptr, size_t itemsize, const std::string &format, size_t ndim,
                 const std::vector<size_t> &shape, const std::vector<size_t> &strides)
         : ptr(ptr), itemsize(itemsize), size(1), format(format),
           ndim(ndim), shape(shape), strides(strides) {
-        for (int i=0; i<ndim; ++i) size *= shape[i];
+        for (size_t i = 0; i < ndim; ++i)
+            size *= shape[i];
     }
 
     buffer_info(Py_buffer *view)
-        : ptr(view->buf), itemsize(view->itemsize), size(1), format(view->format),
-          ndim(view->ndim), shape(view->ndim), strides(view->ndim), view(view) {
-        for (int i = 0; i < view->ndim; ++i) {
+        : ptr(view->buf), itemsize((size_t) view->itemsize), size(1), format(view->format),
+          ndim((size_t) view->ndim), shape((size_t) view->ndim), strides((size_t) view->ndim), view(view) {
+        for (size_t i = 0; i < (size_t) view->ndim; ++i) {
             shape[i] = (size_t) view->shape[i];
             strides[i] = (size_t) view->strides[i];
             size *= shape[i];
@@ -232,6 +230,8 @@ private:
 
 NAMESPACE_BEGIN(detail)
 
+inline static constexpr int log2(size_t n, int k = 0) { return (n <= 1) ? k : log2(n >> 1, k + 1); }
+
 inline std::string error_string();
 
 /// Core part of the 'instance' type which POD (needed to be able to use 'offsetof')
@@ -263,8 +263,9 @@ struct internals {
     std::unordered_map<const void *, void*> registered_types_py;     // PyTypeObject* -> type_info
     std::unordered_map<const void *, void*> registered_instances;    // void * -> PyObject*
     std::unordered_set<std::pair<const PyObject *, const char *>, overload_hash> inactive_overload_cache;
+    std::forward_list<std::function<void(std::exception_ptr)>> registered_exception_translators;
 #if defined(WITH_THREAD)
-    int tstate = 0;
+    decltype(PyThread_create_key()) tstate = 0; // Usually an int but a long on Cygwin64 with Python 3.x
     PyInterpreterState *istate = nullptr;
 #endif
 };
@@ -278,7 +279,7 @@ template<size_t N, size_t ...S> struct make_index_sequence : make_index_sequence
 template<size_t ...S> struct make_index_sequence <0, S...> { typedef index_sequence<S...> type; };
 
 /// Strip the class from a method type
-template <typename T> struct remove_class {};
+template <typename T> struct remove_class { };
 template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...)> { typedef R type(A...); };
 template <typename C, typename R, typename... A> struct remove_class<R (C::*)(A...) const> { typedef R type(A...); };
 
@@ -291,40 +292,37 @@ template <typename T> struct intrinsic_type<T&&>                  { typedef type
 template <typename T, size_t N> struct intrinsic_type<const T[N]> { typedef typename intrinsic_type<T>::type type; };
 template <typename T, size_t N> struct intrinsic_type<T[N]>       { typedef typename intrinsic_type<T>::type type; };
 
-/** \brief SFINAE helper class to check if a copy constructor is usable (in contrast to
- * std::is_copy_constructible, this class also checks if the 'new' operator is accessible */
-template <typename T>  struct is_copy_constructible {
-    template <typename T2> static std::true_type test(decltype(new T2(std::declval<typename std::add_lvalue_reference<T2>::type>())) *);
-    template <typename T2> static std::false_type test(...);
-    static const bool value = std::is_same<std::true_type, decltype(test<T>(nullptr))>::value;
-};
-
-template <typename T>  struct is_move_constructible {
-    template <typename T2> static std::true_type test(decltype(new T2(std::declval<T2>())) *);
-    template <typename T2> static std::false_type test(...);
-    static const bool value = std::is_same<std::true_type, decltype(test<T>(nullptr))>::value;
-};
-
 /// Helper type to replace 'void' in some expressions
 struct void_type { };
 
-/// to_string variant which also accepts strings
-template <typename T> inline typename std::enable_if<!std::is_enum<T>::value, std::string>::type
-to_string(const T &value) { return std::to_string(value); }
-template <> inline std::string to_string(const std::string &value) { return value; }
-template <typename T> inline typename std::enable_if<std::is_enum<T>::value, std::string>::type
-to_string(T value) { return std::to_string((int) value); }
-
 NAMESPACE_END(detail)
 
+#define PYBIND11_RUNTIME_EXCEPTION(name) \
+    class name : public std::runtime_error { public: \
+        name(const std::string &w) : std::runtime_error(w) { }; \
+        name(const char *s) : std::runtime_error(s) { }; \
+        name() : std::runtime_error("") { } \
+    };
+
 // C++ bindings of core Python exceptions
-struct stop_iteration    : public std::runtime_error { public: stop_iteration(const std::string &w="") : std::runtime_error(w)   {} };
-struct index_error       : public std::runtime_error { public: index_error(const std::string &w="")    : std::runtime_error(w)   {} };
-struct error_already_set : public std::runtime_error { public: error_already_set() : std::runtime_error(detail::error_string())  {} };
-/// Thrown when pybind11::cast or handle::call fail due to a type casting error
-struct cast_error        : public std::runtime_error { public: cast_error(const std::string &w = "") : std::runtime_error(w)     {} };
-
-PYBIND11_NOINLINE inline void pybind11_fail(const char *reason) { throw std::runtime_error(reason); }
-PYBIND11_NOINLINE inline void pybind11_fail(const std::string &reason) { throw std::runtime_error(reason); }
+class error_already_set : public std::runtime_error { public: error_already_set() : std::runtime_error(detail::error_string())  {} };
+PYBIND11_RUNTIME_EXCEPTION(stop_iteration)
+PYBIND11_RUNTIME_EXCEPTION(index_error)
+PYBIND11_RUNTIME_EXCEPTION(value_error)
+PYBIND11_RUNTIME_EXCEPTION(cast_error) /// Thrown when pybind11::cast or handle::call fail due to a type casting error
+
+[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const char *reason) { throw std::runtime_error(reason); }
+[[noreturn]] PYBIND11_NOINLINE inline void pybind11_fail(const std::string &reason) { throw std::runtime_error(reason); }
+
+/// Format strings for basic number types
+#define PYBIND11_DECL_FMT(t, v) template<> struct format_descriptor<t> { static constexpr const char *value = v; }
+template <typename T, typename SFINAE = void> struct format_descriptor { };
+template <typename T> struct format_descriptor<T, typename std::enable_if<std::is_integral<T>::value>::type> {
+    static constexpr const char value[2] =
+        { "bBhHiIqQ"[detail::log2(sizeof(T))*2 + (std::is_unsigned<T>::value ? 1 : 0)], '\0' };
+};
+template <typename T> constexpr const char format_descriptor<
+    T, typename std::enable_if<std::is_integral<T>::value>::type>::value[2];
+PYBIND11_DECL_FMT(float, "f"); PYBIND11_DECL_FMT(double, "d"); PYBIND11_DECL_FMT(bool, "?");
 
 NAMESPACE_END(pybind11)
diff --git a/include/pybind11/complex.h b/include/pybind11/complex.h
index ba0b297..f767f35 100644
--- a/include/pybind11/complex.h
+++ b/include/pybind11/complex.h
@@ -26,6 +26,8 @@ NAMESPACE_BEGIN(detail)
 template <typename T> class type_caster<std::complex<T>> {
 public:
     bool load(handle src, bool) {
+        if (!src)
+            return false;
         Py_complex result = PyComplex_AsCComplex(src.ptr());
         if (result.real == -1.0 && PyErr_Occurred()) {
             PyErr_Clear();
diff --git a/include/pybind11/descr.h b/include/pybind11/descr.h
index 1b65f68..6c1d864 100644
--- a/include/pybind11/descr.h
+++ b/include/pybind11/descr.h
@@ -139,7 +139,7 @@ protected:
         const T *it = ptr;
         while (*it++ != (T) 0)
             ;
-        return it - ptr;
+        return static_cast<size_t>(it - ptr);
     }
 
     const std::type_info **m_types = nullptr;
diff --git a/include/pybind11/eigen.h b/include/pybind11/eigen.h
new file mode 100644
index 0000000..7181079
--- /dev/null
+++ b/include/pybind11/eigen.h
@@ -0,0 +1,294 @@
+/*
+    pybind11/eigen.h: Transparent conversion for dense and sparse Eigen matrices
+
+    Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#pragma once
+
+#include "numpy.h"
+
+#if defined(__GNUG__) || defined(__clang__)
+#  pragma GCC diagnostic push
+#  pragma GCC diagnostic ignored "-Wconversion"
+#  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+#endif
+
+#include <Eigen/Core>
+#include <Eigen/SparseCore>
+
+#if defined(__GNUG__) || defined(__clang__)
+#  pragma GCC diagnostic pop
+#endif
+
+#if defined(_MSC_VER)
+#pragma warning(push)
+#pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
+#endif
+
+NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(detail)
+
+template <typename T> class is_eigen_dense {
+private:
+    template<typename Derived> static std::true_type test(const Eigen::DenseBase<Derived> &);
+    static std::false_type test(...);
+public:
+    static constexpr bool value = decltype(test(std::declval<T>()))::value;
+};
+
+template <typename T> class is_eigen_sparse {
+private:
+    template<typename Derived> static std::true_type test(const Eigen::SparseMatrixBase<Derived> &);
+    static std::false_type test(...);
+public:
+    static constexpr bool value = decltype(test(std::declval<T>()))::value;
+};
+
+template<typename Type>
+struct type_caster<Type, typename std::enable_if<is_eigen_dense<Type>::value>::type> {
+    typedef typename Type::Scalar Scalar;
+    static constexpr bool rowMajor = Type::Flags & Eigen::RowMajorBit;
+    static constexpr bool isVector = Type::IsVectorAtCompileTime;
+
+    bool load(handle src, bool) {
+       array_t<Scalar> buffer(src, true);
+       if (!buffer.check())
+           return false;
+
+        buffer_info info = buffer.request();
+        if (info.ndim == 1) {
+            typedef Eigen::Stride<Eigen::Dynamic, 0> Strides;
+            if (!isVector &&
+                !(Type::RowsAtCompileTime == Eigen::Dynamic &&
+                  Type::ColsAtCompileTime == Eigen::Dynamic))
+                return false;
+
+            if (Type::SizeAtCompileTime != Eigen::Dynamic &&
+                info.shape[0] != (size_t) Type::SizeAtCompileTime)
+                return false;
+
+            auto strides = Strides(info.strides[0] / sizeof(Scalar), 0);
+
+            value = Eigen::Map<Type, 0, Strides>(
+                (Scalar *) info.ptr, typename Strides::Index(info.shape[0]), 1, strides);
+        } else if (info.ndim == 2) {
+            typedef Eigen::Stride<Eigen::Dynamic, Eigen::Dynamic> Strides;
+
+            if ((Type::RowsAtCompileTime != Eigen::Dynamic && info.shape[0] != (size_t) Type::RowsAtCompileTime) ||
+                (Type::ColsAtCompileTime != Eigen::Dynamic && info.shape[1] != (size_t) Type::ColsAtCompileTime))
+                return false;
+
+            auto strides = Strides(
+                info.strides[rowMajor ? 0 : 1] / sizeof(Scalar),
+                info.strides[rowMajor ? 1 : 0] / sizeof(Scalar));
+
+            value = Eigen::Map<Type, 0, Strides>(
+                (Scalar *) info.ptr,
+                typename Strides::Index(info.shape[0]),
+                typename Strides::Index(info.shape[1]), strides);
+        } else {
+            return false;
+        }
+        return true;
+    }
+
+    static handle cast(const Type *src, return_value_policy policy, handle parent) {
+        return cast(*src, policy, parent);
+    }
+
+    static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {
+        if (isVector) {
+            return array(buffer_info(
+                /* Pointer to buffer */
+                const_cast<Scalar *>(src.data()),
+                /* Size of one scalar */
+                sizeof(Scalar),
+                /* Python struct-style format descriptor */
+                format_descriptor<Scalar>::value,
+                /* Number of dimensions */
+                1,
+                /* Buffer dimensions */
+                { (size_t) src.size() },
+                /* Strides (in bytes) for each index */
+                { sizeof(Scalar) }
+            )).release();
+        } else {
+            return array(buffer_info(
+                /* Pointer to buffer */
+                const_cast<Scalar *>(src.data()),
+                /* Size of one scalar */
+                sizeof(Scalar),
+                /* Python struct-style format descriptor */
+                format_descriptor<Scalar>::value,
+                /* Number of dimensions */
+                isVector ? 1 : 2,
+                /* Buffer dimensions */
+                { (size_t) src.rows(),
+                  (size_t) src.cols() },
+                /* Strides (in bytes) for each index */
+                { sizeof(Scalar) * (rowMajor ? (size_t) src.cols() : 1),
+                  sizeof(Scalar) * (rowMajor ? 1 : (size_t) src.rows()) }
+            )).release();
+        }
+    }
+
+    template <typename _T> using cast_op_type = pybind11::detail::cast_op_type<_T>;
+
+    static PYBIND11_DESCR name() {
+        return _("numpy.ndarray[dtype=") + npy_format_descriptor<Scalar>::name() +
+               _(", shape=(") + rows() + _(", ") + cols() + _(")]");
+    }
+
+    operator Type*() { return &value; }
+    operator Type&() { return value; }
+
+protected:
+    template <typename T = Type, typename std::enable_if<T::RowsAtCompileTime == Eigen::Dynamic, int>::type = 0>
+    static PYBIND11_DESCR rows() { return _("m"); }
+    template <typename T = Type, typename std::enable_if<T::RowsAtCompileTime != Eigen::Dynamic, int>::type = 0>
+    static PYBIND11_DESCR rows() { return _<T::RowsAtCompileTime>(); }
+    template <typename T = Type, typename std::enable_if<T::ColsAtCompileTime == Eigen::Dynamic, int>::type = 0>
+    static PYBIND11_DESCR cols() { return _("n"); }
+    template <typename T = Type, typename std::enable_if<T::ColsAtCompileTime != Eigen::Dynamic, int>::type = 0>
+    static PYBIND11_DESCR cols() { return _<T::ColsAtCompileTime>(); }
+
+protected:
+    Type value;
+};
+
+template<typename Type>
+struct type_caster<Type, typename std::enable_if<is_eigen_sparse<Type>::value>::type> {
+    typedef typename Type::Scalar Scalar;
+    typedef typename std::remove_reference<decltype(*std::declval<Type>().outerIndexPtr())>::type StorageIndex;
+    typedef typename Type::Index Index;
+    static constexpr bool rowMajor = Type::Flags & Eigen::RowMajorBit;
+
+    bool load(handle src, bool) {
+        if (!src)
+            return false;
+
+        object obj(src, true);
+        object sparse_module = module::import("scipy.sparse");
+        object matrix_type = sparse_module.attr(
+            rowMajor ? "csr_matrix" : "csc_matrix");
+
+        if (obj.get_type() != matrix_type.ptr()) {
+            try {
+                obj = matrix_type(obj);
+            } catch (const error_already_set &) {
+                PyErr_Clear(); 
+                return false;
+            }
+        }
+
+        auto valuesArray = array_t<Scalar>((object) obj.attr("data"));
+        auto innerIndicesArray = array_t<StorageIndex>((object) obj.attr("indices"));
+        auto outerIndicesArray = array_t<StorageIndex>((object) obj.attr("indptr"));
+        auto shape = pybind11::tuple((pybind11::object) obj.attr("shape"));
+        auto nnz = obj.attr("nnz").cast<Index>();
+
+        if (!valuesArray.check() || !innerIndicesArray.check() ||
+            !outerIndicesArray.check())
+            return false;
+
+        buffer_info outerIndices = outerIndicesArray.request();
+        buffer_info innerIndices = innerIndicesArray.request();
+        buffer_info values = valuesArray.request();
+
+        value = Eigen::MappedSparseMatrix<Scalar, Type::Flags, StorageIndex>(
+            shape[0].cast<Index>(),
+            shape[1].cast<Index>(),
+            nnz,
+            static_cast<StorageIndex *>(outerIndices.ptr),
+            static_cast<StorageIndex *>(innerIndices.ptr),
+            static_cast<Scalar *>(values.ptr)
+        );
+
+        return true;
+    }
+
+    static handle cast(const Type *src, return_value_policy policy, handle parent) {
+        return cast(*src, policy, parent);
+    }
+
+    static handle cast(const Type &src, return_value_policy /* policy */, handle /* parent */) {
+        const_cast<Type&>(src).makeCompressed();
+
+        object matrix_type = module::import("scipy.sparse").attr(
+            rowMajor ? "csr_matrix" : "csc_matrix");
+
+        array data(buffer_info(
+            // Pointer to buffer
+            const_cast<Scalar *>(src.valuePtr()),
+            // Size of one scalar
+            sizeof(Scalar),
+            // Python struct-style format descriptor
+            format_descriptor<Scalar>::value,
+            // Number of dimensions
+            1,
+            // Buffer dimensions
+            { (size_t) src.nonZeros() },
+            // Strides
+            { sizeof(Scalar) }
+        ));
+
+        array outerIndices(buffer_info(
+            // Pointer to buffer
+            const_cast<StorageIndex *>(src.outerIndexPtr()),
+            // Size of one scalar
+            sizeof(StorageIndex),
+            // Python struct-style format descriptor
+            format_descriptor<StorageIndex>::value,
+            // Number of dimensions
+            1,
+            // Buffer dimensions
+            { (size_t) (rowMajor ? src.rows() : src.cols()) + 1 },
+            // Strides
+            { sizeof(StorageIndex) }
+        ));
+
+        array innerIndices(buffer_info(
+            // Pointer to buffer
+            const_cast<StorageIndex *>(src.innerIndexPtr()),
+            // Size of one scalar
+            sizeof(StorageIndex),
+            // Python struct-style format descriptor
+            format_descriptor<StorageIndex>::value,
+            // Number of dimensions
+            1,
+            // Buffer dimensions
+            { (size_t) src.nonZeros() },
+            // Strides
+            { sizeof(StorageIndex) }
+        ));
+
+        return matrix_type(
+            std::make_tuple(data, innerIndices, outerIndices),
+            std::make_pair(src.rows(), src.cols())
+        ).release();
+    }
+
+    template <typename _T> using cast_op_type = pybind11::detail::cast_op_type<_T>;
+
+    template <typename T = Type, typename std::enable_if<(T::Flags & Eigen::RowMajorBit) != 0, int>::type = 0>
+    static PYBIND11_DESCR name() { return _("scipy.sparse.csr_matrix[dtype=") + npy_format_descriptor<Scalar>::name() + _("]"); }
+    template <typename T = Type, typename std::enable_if<(T::Flags & Eigen::RowMajorBit) == 0, int>::type = 0>
+    static PYBIND11_DESCR name() { return _("scipy.sparse.csc_matrix[dtype=") + npy_format_descriptor<Scalar>::name() + _("]"); }
+
+    operator Type*() { return &value; }
+    operator Type&() { return value; }
+
+protected:
+    Type value;
+};
+
+NAMESPACE_END(detail)
+NAMESPACE_END(pybind11)
+
+#if defined(_MSC_VER)
+#pragma warning(pop)
+#endif
diff --git a/include/pybind11/exception_translator.h b/include/pybind11/exception_translator.h
new file mode 100644
index 0000000..c48d891
--- /dev/null
+++ b/include/pybind11/exception_translator.h
@@ -0,0 +1,24 @@
+/*
+    pybind11/exception_translator.h: Translators for custom exceptions
+
+    Copyright (c) 2016 Pim Schellart <P.Schellart@princeton.edu>
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#pragma once
+
+#include "pybind11.h"
+#include <forward_list>
+#include <iostream>
+
+NAMESPACE_BEGIN(pybind11)
+
+template <typename ExceptionTranslator>
+void register_exception_translator(ExceptionTranslator&& translator) {
+    detail::get_internals().registered_exception_translators.push_front(std::forward<ExceptionTranslator>(translator));
+}
+
+NAMESPACE_END(pybind11)
+
diff --git a/include/pybind11/functional.h b/include/pybind11/functional.h
index ae3e8b3..f74a9bd 100644
--- a/include/pybind11/functional.h
+++ b/include/pybind11/functional.h
@@ -26,7 +26,7 @@ public:
         object src(src_, true);
         value = [src](Args... args) -> Return {
             gil_scoped_acquire acq;
-            object retval(src.call(std::move(args)...));
+            object retval(src(std::move(args)...));
             /* Visual studio 2015 parser issue: need parentheses around this expression */
             return (retval.template cast<Return>());
         };
diff --git a/include/pybind11/numpy.h b/include/pybind11/numpy.h
index 38d30bf..0180d95 100644
--- a/include/pybind11/numpy.h
+++ b/include/pybind11/numpy.h
@@ -1,5 +1,5 @@
 /*
-    pybind11/numpy.h: Basic NumPy support, auto-vectorization support
+    pybind11/numpy.h: Basic NumPy support, vectorize() wrapper
 
     Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
 
@@ -20,8 +20,7 @@
 #endif
 
 NAMESPACE_BEGIN(pybind11)
-
-template <typename type> struct npy_format_descriptor { };
+namespace detail { template <typename type, typename SFINAE = void> struct npy_format_descriptor { }; }
 
 class array : public buffer {
 public:
@@ -77,9 +76,15 @@ public:
 
     PYBIND11_OBJECT_DEFAULT(array, buffer, lookup_api().PyArray_Check_)
 
+    enum {
+        c_style = API::NPY_C_CONTIGUOUS_,
+        f_style = API::NPY_F_CONTIGUOUS_,
+        forcecast = API::NPY_ARRAY_FORCECAST_
+    };
+
     template <typename Type> array(size_t size, const Type *ptr) {
         API& api = lookup_api();
-        PyObject *descr = api.PyArray_DescrFromType_(npy_format_descriptor<Type>::value);
+        PyObject *descr = api.PyArray_DescrFromType_(detail::npy_format_descriptor<Type>::value);
         if (descr == nullptr)
             pybind11_fail("NumPy: unsupported buffer format!");
         Py_intptr_t shape = (Py_intptr_t) size;
@@ -104,7 +109,7 @@ public:
         if (descr == nullptr)
             pybind11_fail("NumPy: unsupported buffer format '" + info.format + "'!");
         object tmp(api.PyArray_NewFromDescr_(
-            api.PyArray_Type_, descr, info.ndim, (Py_intptr_t *) &info.shape[0],
+            api.PyArray_Type_, descr, (int) info.ndim, (Py_intptr_t *) &info.shape[0],
             (Py_intptr_t *) &info.strides[0], info.ptr, 0, nullptr), false);
         if (info.ptr && tmp)
             tmp = object(api.PyArray_NewCopy_(tmp.ptr(), -1 /* any order */), false);
@@ -120,34 +125,49 @@ protected:
     }
 };
 
-template <typename T> class array_t : public array {
+template <typename T, int ExtraFlags = array::forcecast> class array_t : public array {
 public:
     PYBIND11_OBJECT_CVT(array_t, array, is_non_null, m_ptr = ensure(m_ptr));
     array_t() : array() { }
+    array_t(const buffer_info& info) : array(info) {}
     static bool is_non_null(PyObject *ptr) { return ptr != nullptr; }
     static PyObject *ensure(PyObject *ptr) {
         if (ptr == nullptr)
             return nullptr;
         API &api = lookup_api();
-        PyObject *descr = api.PyArray_DescrFromType_(npy_format_descriptor<T>::value);
-        PyObject *result = api.PyArray_FromAny_(
-            ptr, descr, 0, 0, API::NPY_C_CONTIGUOUS_ | API::NPY_ENSURE_ARRAY_
-                            | API::NPY_ARRAY_FORCECAST_, nullptr);
+        PyObject *descr = api.PyArray_DescrFromType_(detail::npy_format_descriptor<T>::value);
+        PyObject *result = api.PyArray_FromAny_(ptr, descr, 0, 0, API::NPY_ENSURE_ARRAY_ | ExtraFlags, nullptr);
+        if (!result)
+            PyErr_Clear();
         Py_DECREF(ptr);
         return result;
     }
 };
 
-#define DECL_FMT(t, n) template<> struct npy_format_descriptor<t> { enum { value = array::API::n }; }
-DECL_FMT(int8_t, NPY_BYTE_);  DECL_FMT(uint8_t, NPY_UBYTE_); DECL_FMT(int16_t, NPY_SHORT_);
-DECL_FMT(uint16_t, NPY_USHORT_); DECL_FMT(int32_t, NPY_INT_); DECL_FMT(uint32_t, NPY_UINT_);
-DECL_FMT(int64_t, NPY_LONGLONG_); DECL_FMT(uint64_t, NPY_ULONGLONG_); DECL_FMT(float, NPY_FLOAT_);
-DECL_FMT(double, NPY_DOUBLE_); DECL_FMT(bool, NPY_BOOL_); DECL_FMT(std::complex<float>, NPY_CFLOAT_);
-DECL_FMT(std::complex<double>, NPY_CDOUBLE_);
-#undef DECL_FMT
-
 NAMESPACE_BEGIN(detail)
 
+template <typename T> struct npy_format_descriptor<T, typename std::enable_if<std::is_integral<T>::value>::type> {
+private:
+    constexpr static const int values[8] = {
+        array::API::NPY_BYTE_, array::API::NPY_UBYTE_, array::API::NPY_SHORT_,    array::API::NPY_USHORT_,
+        array::API::NPY_INT_,  array::API::NPY_UINT_,  array::API::NPY_LONGLONG_, array::API::NPY_ULONGLONG_ };
+public:
+    enum { value = values[detail::log2(sizeof(T)) * 2 + (std::is_unsigned<T>::value ? 1 : 0)] };
+    template <typename T2 = T, typename std::enable_if<std::is_signed<T2>::value, int>::type = 0>
+    static PYBIND11_DESCR name() { return _("int") + _<sizeof(T)*8>(); }
+    template <typename T2 = T, typename std::enable_if<!std::is_signed<T2>::value, int>::type = 0>
+    static PYBIND11_DESCR name() { return _("uint") + _<sizeof(T)*8>(); }
+};
+template <typename T> constexpr const int npy_format_descriptor<
+    T, typename std::enable_if<std::is_integral<T>::value>::type>::values[8];
+
+#define DECL_FMT(Type, NumPyName, Name) template<> struct npy_format_descriptor<Type> { \
+    enum { value = array::API::NumPyName }; \
+    static PYBIND11_DESCR name() { return _(Name); } }
+DECL_FMT(float, NPY_FLOAT_, "float32"); DECL_FMT(double, NPY_DOUBLE_, "float64"); DECL_FMT(bool, NPY_BOOL_, "bool");
+DECL_FMT(std::complex<float>, NPY_CFLOAT_, "complex64"); DECL_FMT(std::complex<double>, NPY_CDOUBLE_, "complex128");
+#undef DECL_FMT
+
 template  <class T>
 using array_iterator = typename std::add_pointer<T>::type;
 
@@ -241,7 +261,7 @@ private:
 
         while (buffer_shape_iter != buffer.shape.rend()) {
             if (*shape_iter == *buffer_shape_iter)
-                *strides_iter = static_cast<int>(*buffer_strides_iter);
+                *strides_iter = static_cast<size_t>(*buffer_strides_iter);
             else
                 *strides_iter = 0;
 
@@ -266,12 +286,12 @@ private:
 };
 
 template <size_t N>
-bool broadcast(const std::array<buffer_info, N>& buffers, int& ndim, std::vector<size_t>& shape) {
-    ndim = std::accumulate(buffers.begin(), buffers.end(), 0, [](int res, const buffer_info& buf) {
+bool broadcast(const std::array<buffer_info, N>& buffers, size_t& ndim, std::vector<size_t>& shape) {
+    ndim = std::accumulate(buffers.begin(), buffers.end(), size_t(0), [](size_t res, const buffer_info& buf) {
         return std::max(res, buf.ndim);
     });
 
-    shape = std::vector<size_t>(static_cast<size_t>(ndim), 1);
+    shape = std::vector<size_t>(ndim, 1);
     bool trivial_broadcast = true;
     for (size_t i = 0; i < N; ++i) {
         auto res_iter = shape.rbegin();
@@ -298,26 +318,26 @@ struct vectorize_helper {
     template <typename T>
     vectorize_helper(T&&f) : f(std::forward<T>(f)) { }
 
-    object operator()(array_t<Args>... args) {
+    object operator()(array_t<Args, array::c_style | array::forcecast>... args) {
         return run(args..., typename make_index_sequence<sizeof...(Args)>::type());
     }
 
-    template <size_t ... Index> object run(array_t<Args>&... args, index_sequence<Index...> index) {
+    template <size_t ... Index> object run(array_t<Args, array::c_style | array::forcecast>&... args, index_sequence<Index...> index) {
         /* Request buffers from all parameters */
         const size_t N = sizeof...(Args);
 
         std::array<buffer_info, N> buffers {{ args.request()... }};
 
         /* Determine dimensions parameters of output array */
-        int ndim = 0;
+        size_t ndim = 0;
         std::vector<size_t> shape(0);
         bool trivial_broadcast = broadcast(buffers, ndim, shape);
-                
+
         size_t size = 1;
         std::vector<size_t> strides(ndim);
         if (ndim > 0) {
             strides[ndim-1] = sizeof(Return);
-            for (int i = ndim - 1; i > 0; --i) {
+            for (size_t i = ndim - 1; i > 0; --i) {
                 strides[i - 1] = strides[i] * shape[i];
                 size *= shape[i];
             }
@@ -328,13 +348,13 @@ struct vectorize_helper {
             return cast(f(*((Args *) buffers[Index].ptr)...));
 
         array result(buffer_info(nullptr, sizeof(Return),
-            format_descriptor<Return>::value(),
+            format_descriptor<Return>::value,
             ndim, shape, strides));
 
         buffer_info buf = result.request();
         Return *output = (Return *) buf.ptr;
 
-        if(trivial_broadcast) {
+        if (trivial_broadcast) {
             /* Call the function */
             for (size_t i=0; i<size; ++i) {
                 output[i] = f((buffers[Index].size == 1
@@ -364,8 +384,8 @@ struct vectorize_helper {
     }
 };
 
-template <typename T> struct handle_type_name<array_t<T>> {
-    static PYBIND11_DESCR name() { return _("array[") + type_caster<T>::name() + _("]"); }
+template <typename T, int Flags> struct handle_type_name<array_t<T, Flags>> {
+    static PYBIND11_DESCR name() { return _("numpy.ndarray[dtype=") + type_caster<T>::name() + _("]"); }
 };
 
 NAMESPACE_END(detail)
diff --git a/include/pybind11/pybind11.h b/include/pybind11/pybind11.h
index 8a3907e..3483aea 100644
--- a/include/pybind11/pybind11.h
+++ b/include/pybind11/pybind11.h
@@ -20,11 +20,13 @@
 #elif defined(__ICC) || defined(__INTEL_COMPILER)
 #  pragma warning(push)
 #  pragma warning(disable:2196)  // warning #2196: routine is both "inline" and "noinline"
-#elif defined(__GNUG__) and !defined(__clang__)
+#elif defined(__GNUG__) && !defined(__clang__)
 #  pragma GCC diagnostic push
 #  pragma GCC diagnostic ignored "-Wunused-but-set-parameter"
 #  pragma GCC diagnostic ignored "-Wunused-but-set-variable"
 #  pragma GCC diagnostic ignored "-Wmissing-field-initializers"
+#  pragma GCC diagnostic ignored "-Wstrict-aliasing"
+#  pragma GCC diagnostic ignored "-Wattributes"
 #endif
 
 #include "attr.h"
@@ -33,77 +35,32 @@ NAMESPACE_BEGIN(pybind11)
 
 /// Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object
 class cpp_function : public function {
-protected:
-    /// Picks a suitable return value converter from cast.h
-    template <typename T> using return_value_caster =
-        detail::type_caster<typename std::conditional<
-            std::is_void<T>::value, detail::void_type, typename detail::intrinsic_type<T>::type>::type>;
-
-    /// Picks a suitable argument value converter from cast.h
-    template <typename... T> using arg_value_caster =
-        detail::type_caster<typename std::tuple<T...>>;
 public:
     cpp_function() { }
 
-    /// Vanilla function pointers
+    /// Construct a cpp_function from a vanilla function pointer
     template <typename Return, typename... Args, typename... Extra>
     cpp_function(Return (*f)(Args...), const Extra&... extra) {
-        auto rec = new detail::function_record();
-        rec->data = (void *) f;
-
-        typedef arg_value_caster<Args...> cast_in;
-        typedef return_value_caster<Return> cast_out;
-
-        /* Dispatch code which converts function arguments and performs the actual function call */
-        rec->impl = [](detail::function_record *rec, handle pyArgs, handle parent) -> handle {
-            cast_in args;
-
-            /* Try to cast the function arguments into the C++ domain */
-            if (!args.load(pyArgs, true))
-                return PYBIND11_TRY_NEXT_OVERLOAD;
-
-            /* Invoke call policy pre-call hook */
-            detail::process_attributes<Extra...>::precall(pyArgs);
-
-            /* Do the call and convert the return value back into the Python domain */
-            handle result = cast_out::cast(
-                args.template call<Return>((Return (*) (Args...)) rec->data),
-                rec->policy, parent);
-
-            /* Invoke call policy post-call hook */
-            detail::process_attributes<Extra...>::postcall(pyArgs, result);
-
-            return result;
-        };
-
-        /* Process any user-provided function attributes */
-        detail::process_attributes<Extra...>::init(extra..., rec);
-
-        /* Generate a readable signature describing the function's arguments and return value types */
-        using detail::descr;
-        PYBIND11_DESCR signature = cast_in::name() + detail::_(" -> ") + cast_out::name();
-
-        /* Register the function with Python from generic (non-templated) code */
-        initialize(rec, signature.text(), signature.types(), sizeof...(Args));
+        initialize(f, f, extra...);
     }
 
-    /// Delegating helper constructor to deal with lambda functions
+    /// Construct a cpp_function from a lambda function (possibly with internal state)
     template <typename Func, typename... Extra> cpp_function(Func &&f, const Extra&... extra) {
         initialize(std::forward<Func>(f),
                    (typename detail::remove_class<decltype(
                        &std::remove_reference<Func>::type::operator())>::type *) nullptr, extra...);
     }
 
-    /// Delegating helper constructor to deal with class methods (non-const)
-    template <typename Return, typename Class, typename... Arg, typename... Extra> cpp_function(
-            Return (Class::*f)(Arg...), const Extra&... extra) {
+    /// Construct a cpp_function from a class method (non-const)
+    template <typename Return, typename Class, typename... Arg, typename... Extra>
+            cpp_function(Return (Class::*f)(Arg...), const Extra&... extra) {
         initialize([f](Class *c, Arg... args) -> Return { return (c->*f)(args...); },
                    (Return (*) (Class *, Arg...)) nullptr, extra...);
     }
 
-    /// Delegating helper constructor to deal with class methods (const)
-    template <typename Return, typename Class, typename... Arg, typename... Extra> cpp_function(
-            Return (Class::*f)(Arg...) const, const Extra&... extra) {
+    /// Construct a cpp_function from a class method (const)
+    template <typename Return, typename Class, typename... Arg, typename... Extra>
+            cpp_function(Return (Class::*f)(Arg...) const, const Extra&... extra) {
         initialize([f](const Class *c, Arg... args) -> Return { return (c->*f)(args...); },
                    (Return (*)(const Class *, Arg ...)) nullptr, extra...);
     }
@@ -115,39 +72,51 @@ protected:
     /// Special internal constructor for functors, lambda functions, etc.
     template <typename Func, typename Return, typename... Args, typename... Extra>
     void initialize(Func &&f, Return (*)(Args...), const Extra&... extra) {
+        static_assert(detail::expected_num_args<Extra...>(sizeof...(Args)),
+                      "The number of named arguments does not match the function signature");
+
         struct capture { typename std::remove_reference<Func>::type f; };
 
         /* Store the function including any extra state it might have (e.g. a lambda capture object) */
         auto rec = new detail::function_record();
-        rec->data = new capture { std::forward<Func>(f) };
 
-        /* Create a cleanup handler, but only if we have to (less generated code) */
-        if (!std::is_trivially_destructible<Func>::value)
-            rec->free_data = [](void *ptr) { delete (capture *) ptr; };
-        else
-            rec->free_data = operator delete;
+        /* Store the capture object directly in the function record if there is enough space */
+        if (sizeof(capture) <= sizeof(rec->data)) {
+            new ((capture *) &rec->data) capture { std::forward<Func>(f) };
+            if (!std::is_trivially_destructible<Func>::value)
+                rec->free_data = [](detail::function_record *r) { ((capture *) &r->data)->~capture(); };
+        } else {
+            rec->data[0] = new capture { std::forward<Func>(f) };
+            rec->free_data = [](detail::function_record *r) { delete ((capture *) r->data[0]); };
+        }
 
-        typedef arg_value_caster<Args...> cast_in;
-        typedef return_value_caster<Return> cast_out;
+        /* Type casters for the function arguments and return value */
+        typedef detail::type_caster<typename std::tuple<Args...>> cast_in;
+        typedef detail::type_caster<typename std::conditional<
+            std::is_void<Return>::value, detail::void_type,
+            typename detail::intrinsic_type<Return>::type>::type> cast_out;
 
         /* Dispatch code which converts function arguments and performs the actual function call */
-        rec->impl = [](detail::function_record *rec, handle pyArgs, handle parent) -> handle {
-            cast_in args;
+        rec->impl = [](detail::function_record *rec, handle args, handle kwargs, handle parent) -> handle {
+            cast_in args_converter;
 
             /* Try to cast the function arguments into the C++ domain */
-            if (!args.load(pyArgs, true))
+            if (!args_converter.load_args(args, kwargs, true))
                 return PYBIND11_TRY_NEXT_OVERLOAD;
 
             /* Invoke call policy pre-call hook */
-            detail::process_attributes<Extra...>::precall(pyArgs);
+            detail::process_attributes<Extra...>::precall(args);
+
+            /* Get a pointer to the capture object */
+            capture *cap = (capture *) (sizeof(capture) <= sizeof(rec->data)
+                                        ? &rec->data : rec->data[0]);
 
-            /* Do the call and convert the return value back into the Python domain */
-            handle result = cast_out::cast(
-                args.template call<Return>(((capture *) rec->data)->f),
-                rec->policy, parent);
+            /* Perform the functioncall */
+            handle result = cast_out::cast(args_converter.template call<Return>(cap->f),
+                                           rec->policy, parent);
 
             /* Invoke call policy post-call hook */
-            detail::process_attributes<Extra...>::postcall(pyArgs, result);
+            detail::process_attributes<Extra...>::postcall(args, result);
 
             return result;
         };
@@ -160,12 +129,15 @@ protected:
         PYBIND11_DESCR signature = cast_in::name() + detail::_(" -> ") + cast_out::name();
 
         /* Register the function with Python from generic (non-templated) code */
-        initialize(rec, signature.text(), signature.types(), sizeof...(Args));
+        initialize_generic(rec, signature.text(), signature.types(), sizeof...(Args));
+
+        if (cast_in::has_args) rec->has_args = true;
+        if (cast_in::has_kwargs) rec->has_kwargs = true;
     }
 
     /// Register a function call with Python (generic non-templated code goes here)
-    void initialize(detail::function_record *rec, const char *text,
-                    const std::type_info *const *types, int args) {
+    void initialize_generic(detail::function_record *rec, const char *text,
+                            const std::type_info *const *types, int args) {
 
         /* Create copies of all referenced C-style strings */
         rec->name = strdup(rec->name ? rec->name : "");
@@ -176,7 +148,7 @@ protected:
             if (a.descr)
                 a.descr = strdup(a.descr);
             else if (a.value)
-                a.descr = strdup(((std::string) ((object) handle(a.value).attr("__repr__")).call().str()).c_str());
+                a.descr = strdup(((std::string) ((object) handle(a.value).attr("__repr__"))().str()).c_str());
         }
         auto const &registered_types = detail::get_internals().registered_types_cpp;
 
@@ -231,18 +203,18 @@ protected:
         if (strcmp(rec->name, "__next__") == 0) {
             std::free(rec->name);
             rec->name = strdup("next");
+        } else if (strcmp(rec->name, "__bool__") == 0) {
+            std::free(rec->name);
+            rec->name = strdup("__nonzero__");
         }
 #endif
 
-        if (!rec->args.empty() && (int) rec->args.size() != args)
-            pybind11_fail(
-                "cpp_function(): function \"" + std::string(rec->name) + "\" takes " +
-                std::to_string(args) + " arguments, but " + std::to_string(rec->args.size()) +
-                " pybind11::arg entries were specified!");
-
-        rec->is_constructor = !strcmp(rec->name, "__init__");
         rec->signature = strdup(signature.c_str());
         rec->args.shrink_to_fit();
+        rec->is_constructor = !strcmp(rec->name, "__init__") || !strcmp(rec->name, "__setstate__");
+        rec->has_args = false;
+        rec->has_kwargs = false;
+        rec->nargs = (uint16_t) args;
 
 #if PY_MAJOR_VERSION < 3
         if (rec->sibling && PyMethod_Check(rec->sibling.ptr()))
@@ -336,7 +308,7 @@ protected:
         while (rec) {
             detail::function_record *next = rec->next;
             if (rec->free_data)
-                rec->free_data(rec->data);
+                rec->free_data(rec);
             std::free((char *) rec->name);
             std::free((char *) rec->doc);
             std::free((char *) rec->signature);
@@ -361,15 +333,15 @@ protected:
                                 *it = overloads;
 
         /* Need to know how many arguments + keyword arguments there are to pick the right overload */
-        int nargs = (int) PyTuple_Size(args),
-            nkwargs = kwargs ? (int) PyDict_Size(kwargs) : 0;
+        size_t nargs = (size_t) PyTuple_GET_SIZE(args),
+               nkwargs = kwargs ? (size_t) PyDict_Size(kwargs) : 0;
 
-        handle parent = nargs > 0 ? PyTuple_GetItem(args, 0) : nullptr,
+        handle parent = nargs > 0 ? PyTuple_GET_ITEM(args, 0) : nullptr,
                result = PYBIND11_TRY_NEXT_OVERLOAD;
         try {
             for (; it != nullptr; it = it->next) {
                 tuple args_(args, true);
-                int kwargs_consumed = 0;
+                size_t kwargs_consumed = 0;
 
                 /* For each overload:
                    1. If the required list of arguments is longer than the
@@ -378,10 +350,11 @@ protected:
                    2. Ensure that all keyword arguments were "consumed"
                    3. Call the function call dispatcher (function_record::impl)
                  */
-
-                if (nargs < (int) it->args.size()) {
-                    args_ = tuple(it->args.size());
-                    for (int i = 0; i < nargs; ++i) {
+                size_t nargs_ = nargs;
+                if (nargs < it->args.size()) {
+                    nargs_ = it->args.size();
+                    args_ = tuple(nargs_);
+                    for (size_t i = 0; i < nargs; ++i) {
                         handle item = PyTuple_GET_ITEM(args, i);
                         PyTuple_SET_ITEM(args_.ptr(), i, item.inc_ref().ptr());
                     }
@@ -404,30 +377,49 @@ protected:
                         if (value) {
                             PyTuple_SET_ITEM(args_.ptr(), index, value.inc_ref().ptr());
                         } else {
-                            kwargs_consumed = -1; /* definite failure */
+                            kwargs_consumed = (size_t) -1; /* definite failure */
                             break;
                         }
                     }
                 }
 
-                if (kwargs_consumed == nkwargs)
-                    result = it->impl(it, args_, parent);
+                try {
+                    if ((kwargs_consumed == nkwargs || it->has_kwargs) &&
+                        (nargs_ == it->nargs || it->has_args))
+                        result = it->impl(it, args_, kwargs, parent);
+                } catch (cast_error &) {
+                    result = PYBIND11_TRY_NEXT_OVERLOAD;
+                }
 
                 if (result.ptr() != PYBIND11_TRY_NEXT_OVERLOAD)
                     break;
             }
-        } catch (const error_already_set &)      {                                                 return nullptr;
-        } catch (const index_error &e)           { PyErr_SetString(PyExc_IndexError,    e.what()); return nullptr;
-        } catch (const stop_iteration &e)        { PyErr_SetString(PyExc_StopIteration, e.what()); return nullptr;
-        } catch (const std::bad_alloc &e)        { PyErr_SetString(PyExc_MemoryError,   e.what()); return nullptr;
-        } catch (const std::domain_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return nullptr;
-        } catch (const std::invalid_argument &e) { PyErr_SetString(PyExc_ValueError,    e.what()); return nullptr;
-        } catch (const std::length_error &e)     { PyErr_SetString(PyExc_ValueError,    e.what()); return nullptr;
-        } catch (const std::out_of_range &e)     { PyErr_SetString(PyExc_IndexError,    e.what()); return nullptr;
-        } catch (const std::range_error &e)      { PyErr_SetString(PyExc_ValueError,    e.what()); return nullptr;
-        } catch (const std::exception &e)        { PyErr_SetString(PyExc_RuntimeError,  e.what()); return nullptr;
+        } catch (const error_already_set &) {
+            return nullptr;
         } catch (...) {
-            PyErr_SetString(PyExc_RuntimeError, "Caught an unknown exception!");
+            /* When an exception is caught, give each registered exception
+               translator a chance to translate it to a Python exception
+               in reverse order of registration.
+              
+               A translator may choose to do one of the following:
+              
+                - catch the exception and call PyErr_SetString or PyErr_SetObject
+                  to set a standard (or custom) Python exception, or
+                - do nothing and let the exception fall through to the next translator, or
+                - delegate translation to the next translator by throwing a new type of exception. */
+
+            auto last_exception = std::current_exception(); 
+            auto &registered_exception_translators = pybind11::detail::get_internals().registered_exception_translators;
+            for (auto& translator : registered_exception_translators) {
+                try {
+                    translator(last_exception);
+                } catch (...) {
+                    last_exception = std::current_exception();
+                    continue;
+                }
+                return nullptr;
+            }
+            PyErr_SetString(PyExc_SystemError, "Exception escaped from default exception translator!");
             return nullptr;
         }
 
@@ -440,6 +432,14 @@ protected:
                 msg += it2->signature;
                 msg += "\n";
             }
+            msg += "    Invoked with: ";
+            tuple args_(args, true);
+            for( std::size_t ti = 0; ti != args_.size(); ++ti)
+            {
+                msg += static_cast<std::string>(static_cast<object>(args_[ti]).str());
+                if ((ti + 1) != args_.size() )
+                    msg += ", ";
+            }
             PyErr_SetString(PyExc_TypeError, msg.c_str());
             return nullptr;
         } else if (!result) {
@@ -452,7 +452,7 @@ protected:
             if (overloads->is_constructor) {
                 /* When a constructor ran successfully, the corresponding
                    holder type (e.g. std::unique_ptr) must still be initialized. */
-                PyObject *inst = PyTuple_GetItem(args, 0);
+                PyObject *inst = PyTuple_GET_ITEM(args, 0);
                 auto tinfo = detail::get_type_info(Py_TYPE(inst));
                 tinfo->init_holder(inst, nullptr);
             }
@@ -513,7 +513,7 @@ public:
 NAMESPACE_BEGIN(detail)
 /// Generic support for creating new Python heap types
 class generic_type : public object {
-    template <typename type, typename holder_type> friend class class_;
+    template <typename type, typename holder_type, typename type_alias> friend class class_;
 public:
     PYBIND11_OBJECT_DEFAULT(generic_type, object, PyType_Check)
 protected:
@@ -530,6 +530,14 @@ protected:
             }
         }
 
+        auto &internals = get_internals();
+        auto tindex = std::type_index(*(rec->type));
+
+        if (internals.registered_types_cpp.find(tindex) !=
+            internals.registered_types_cpp.end())
+            pybind11_fail("generic_type: type \"" + std::string(rec->name) +
+                          "\" is already registered!");
+
         object type_holder(PyType_Type.tp_alloc(&PyType_Type, 0), false);
         object name(PYBIND11_FROM_STRING(rec->name), false);
         auto type = (PyHeapTypeObject*) type_holder.ptr();
@@ -538,12 +546,11 @@ protected:
             pybind11_fail("generic_type: unable to create type object!");
 
         /* Register supplemental type information in C++ dict */
-        auto &internals = get_internals();
         detail::type_info *tinfo = new detail::type_info();
         tinfo->type = (PyTypeObject *) type;
         tinfo->type_size = rec->type_size;
         tinfo->init_holder = rec->init_holder;
-        internals.registered_types_cpp[std::type_index(*(rec->type))] = tinfo;
+        internals.registered_types_cpp[tindex] = tinfo;
         internals.registered_types_py[type] = tinfo;
 
         object scope_module;
@@ -557,7 +564,7 @@ protected:
                                               : std::string(rec->name));
         /* Basic type attributes */
         type->ht_type.tp_name = strdup(full_name.c_str());
-        type->ht_type.tp_basicsize = rec->instance_size;
+        type->ht_type.tp_basicsize = (ssize_t) rec->instance_size;
         type->ht_type.tp_base = (PyTypeObject *) rec->base_handle.ptr();
         rec->base_handle.inc_ref();
 
@@ -712,14 +719,14 @@ protected:
         view->ndim = 1;
         view->internal = info;
         view->buf = info->ptr;
-        view->itemsize = info->itemsize;
+        view->itemsize = (ssize_t) info->itemsize;
         view->len = view->itemsize;
         for (auto s : info->shape)
             view->len *= s;
         if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT)
             view->format = const_cast<char *>(info->format.c_str());
         if ((flags & PyBUF_STRIDES) == PyBUF_STRIDES) {
-            view->ndim = info->ndim;
+            view->ndim = (int) info->ndim;
             view->strides = (ssize_t *) &info->strides[0];
             view->shape = (ssize_t *) &info->shape[0];
         }
@@ -731,7 +738,7 @@ protected:
 };
 NAMESPACE_END(detail)
 
-template <typename type, typename holder_type = std::unique_ptr<type>>
+template <typename type, typename holder_type = std::unique_ptr<type>, typename type_alias = type>
 class class_ : public detail::generic_type {
 public:
     typedef detail::instance<type, holder_type> instance_type;
@@ -753,6 +760,11 @@ public:
         detail::process_attributes<Extra...>::init(extra..., &record);
 
         detail::generic_type::initialize(&record);
+
+        if (!std::is_same<type, type_alias>::value) {
+            auto &instances = pybind11::detail::get_internals().registered_types_cpp;
+            instances[std::type_index(typeid(type_alias))] = instances[std::type_index(typeid(type))];
+        }
     }
 
     template <typename Func, typename... Extra>
@@ -790,6 +802,12 @@ public:
         return *this;
     }
 
+    template <typename... Args, typename... Extra>
+    class_ &def(const detail::init_alias<Args...> &init, const Extra&... extra) {
+        init.template execute<type>(*this, extra...);
+        return *this;
+    }
+
     template <typename Func> class_& def_buffer(Func &&func) {
         struct capture { Func func; };
         capture *ptr = new capture { std::forward<Func>(func) };
@@ -852,9 +870,20 @@ public:
     template <typename... Extra>
     class_ &def_property_static(const char *name, const cpp_function &fget, const cpp_function &fset, const Extra& ...extra) {
         auto rec_fget = get_function_record(fget), rec_fset = get_function_record(fset);
+        char *doc_prev = rec_fget->doc; /* 'extra' field may include a property-specific documentation string */
         detail::process_attributes<Extra...>::init(extra..., rec_fget);
-        if (rec_fset)
+        if (rec_fget->doc && rec_fget->doc != doc_prev) {
+            free(doc_prev);
+            rec_fget->doc = strdup(rec_fget->doc);
+        }
+        if (rec_fset) {
+            doc_prev = rec_fset->doc;
             detail::process_attributes<Extra...>::init(extra..., rec_fset);
+            if (rec_fset->doc && rec_fset->doc != doc_prev) {
+                free(doc_prev);
+                rec_fset->doc = strdup(rec_fset->doc);
+            }
+        }
         pybind11::str doc_obj = pybind11::str(rec_fget->doc ? rec_fget->doc : "");
         object property(
             PyObject_CallFunctionObjArgs((PyObject *) &PyProperty_Type, fget.ptr() ? fget.ptr() : Py_None,
@@ -866,11 +895,6 @@ public:
         return *this;
     }
 
-    template <typename target> class_ alias() {
-        auto &instances = pybind11::detail::get_internals().registered_types_cpp;
-        instances[std::type_index(typeid(target))] = instances[std::type_index(typeid(type))];
-        return *this;
-    }
 private:
     /// Initialize holder object, variant 1: object derives from enable_shared_from_this
     template <typename T>
@@ -937,10 +961,11 @@ public:
                 ((it == entries->end()) ? std::string("???")
                                         : std::string(it->second));
         });
-        this->def("__init__", [](Type& value, int i) { value = (Type) i; });
+        this->def("__init__", [](Type& value, int i) { value = (Type)i; });
+        this->def("__init__", [](Type& value, int i) { new (&value) Type((Type) i); });
         this->def("__int__", [](Type value) { return (int) value; });
-        this->def("__eq__", [](const Type &value, Type value2) { return value == value2; });
-        this->def("__ne__", [](const Type &value, Type value2) { return value != value2; });
+        this->def("__eq__", [](const Type &value, Type *value2) { return value2 && value == *value2; });
+        this->def("__ne__", [](const Type &value, Type *value2) { return !value2 || value != *value2; });
         this->def("__hash__", [](const Type &value) { return (int) value; });
         m_entries = entries;
     }
@@ -968,9 +993,31 @@ private:
 
 NAMESPACE_BEGIN(detail)
 template <typename... Args> struct init {
-    template <typename Base, typename Holder, typename... Extra> void execute(pybind11::class_<Base, Holder> &class_, const Extra&... extra) const {
+    template <typename Base, typename Holder, typename Alias, typename... Extra,
+              typename std::enable_if<std::is_same<Base, Alias>::value, int>::type = 0>
+    void execute(pybind11::class_<Base, Holder, Alias> &class_, const Extra&... extra) const {
         /// Function which calls a specific C++ in-place constructor
-        class_.def("__init__", [](Base *instance, Args... args) { new (instance) Base(args...); }, extra...);
+        class_.def("__init__", [](Base *self_, Args... args) { new (self_) Base(args...); }, extra...);
+    }
+
+    template <typename Base, typename Holder, typename Alias, typename... Extra,
+              typename std::enable_if<!std::is_same<Base, Alias>::value &&
+                                       std::is_constructible<Base, Args...>::value, int>::type = 0>
+    void execute(pybind11::class_<Base, Holder, Alias> &class_, const Extra&... extra) const {
+        handle cl_type = class_;
+        class_.def("__init__", [cl_type](handle self_, Args... args) {
+                if (self_.get_type() == cl_type)
+                    new (self_.cast<Base *>()) Base(args...);
+                else
+                    new (self_.cast<Alias *>()) Alias(args...);
+            }, extra...);
+    }
+
+    template <typename Base, typename Holder, typename Alias, typename... Extra,
+              typename std::enable_if<!std::is_same<Base, Alias>::value &&
+                                      !std::is_constructible<Base, Args...>::value, int>::type = 0>
+    void execute(pybind11::class_<Base, Holder, Alias> &class_, const Extra&... extra) const {
+        class_.def("__init__", [](Alias *self, Args... args) { new (self) Alias(args...); }, extra...);
     }
 };
 
@@ -1000,13 +1047,16 @@ NAMESPACE_END(detail)
 
 template <typename... Args> detail::init<Args...> init() { return detail::init<Args...>(); }
 
-template <typename Iterator, typename... Extra> iterator make_iterator(Iterator first, Iterator last, Extra&&... extra) {
+template <typename Iterator,
+          typename ValueType = decltype(*std::declval<Iterator>()),
+          typename... Extra>
+iterator make_iterator(Iterator first, Iterator last, Extra &&... extra) {
     typedef detail::iterator_state<Iterator> state;
 
     if (!detail::get_type_info(typeid(state))) {
         class_<state>(handle(), "")
             .def("__iter__", [](state &s) -> state& { return s; })
-            .def("__next__", [](state &s) -> decltype(*std::declval<Iterator>()) {
+            .def("__next__", [](state &s) -> ValueType {
                 if (s.it == s.end)
                     throw stop_iteration();
                 return *s.it++;
@@ -1055,6 +1105,11 @@ template <typename InputType, typename OutputType> void implicitly_convertible()
  *    can be handy to prevent cases where callbacks issued from an external
  *    thread would otherwise constantly construct and destroy thread state data
  *    structures.
+ *
+ * See the Python bindings of NanoGUI (http://github.com/wjakob/nanogui) for an
+ * example which uses features 2 and 3 to migrate the Python thread of
+ * execution to another thread (to run the event loop on the original thread,
+ * in this case).
  */
 
 class gil_scoped_acquire {
@@ -1132,7 +1187,7 @@ public:
     gil_scoped_release(bool disassoc = false) : disassoc(disassoc) {
         tstate = PyEval_SaveThread();
         if (disassoc) {
-            int key = detail::get_internals().tstate;
+            auto key = detail::get_internals().tstate;
             #if PY_MAJOR_VERSION < 3
                 PyThread_delete_key_value(key);
             #else
@@ -1145,7 +1200,7 @@ public:
             return;
         PyEval_RestoreThread(tstate);
         if (disassoc) {
-            int key = detail::get_internals().tstate;
+            auto key = detail::get_internals().tstate;
             #if PY_MAJOR_VERSION < 3
                 PyThread_delete_key_value(key);
             #endif
@@ -1193,19 +1248,25 @@ inline function get_overload(const void *this_ptr, const char *name)  {
     return overload;
 }
 
-#define PYBIND11_OVERLOAD_INT(ret_type, class_name, name, ...) { \
+#define PYBIND11_OVERLOAD_INT(ret_type, name, ...) { \
         pybind11::gil_scoped_acquire gil; \
-        pybind11::function overload = pybind11::get_overload(this, #name); \
+        pybind11::function overload = pybind11::get_overload(this, name); \
         if (overload) \
-            return overload.call(__VA_ARGS__).template cast<ret_type>();  }
+            return overload(__VA_ARGS__).template cast<ret_type>();  }
+
+#define PYBIND11_OVERLOAD_NAME(ret_type, cname, name, fn, ...) \
+    PYBIND11_OVERLOAD_INT(ret_type, name, __VA_ARGS__) \
+    return cname::fn(__VA_ARGS__)
+
+#define PYBIND11_OVERLOAD_PURE_NAME(ret_type, cname, name, fn, ...) \
+    PYBIND11_OVERLOAD_INT(ret_type, name, __VA_ARGS__) \
+    pybind11::pybind11_fail("Tried to call pure virtual function \"" #cname "::" name "\"");
 
-#define PYBIND11_OVERLOAD(ret_type, class_name, name, ...) \
-    PYBIND11_OVERLOAD_INT(ret_type, class_name, name, __VA_ARGS__) \
-    return class_name::name(__VA_ARGS__)
+#define PYBIND11_OVERLOAD(ret_type, cname, fn, ...) \
+    PYBIND11_OVERLOAD_NAME(ret_type, cname, #fn, fn, __VA_ARGS__)
 
-#define PYBIND11_OVERLOAD_PURE(ret_type, class_name, name, ...) \
-    PYBIND11_OVERLOAD_INT(ret_type, class_name, name, __VA_ARGS__) \
-    pybind11::pybind11_fail("Tried to call pure virtual function \"" #name "\"");
+#define PYBIND11_OVERLOAD_PURE(ret_type, cname, fn, ...) \
+    PYBIND11_OVERLOAD_PURE_NAME(ret_type, cname, #fn, fn, __VA_ARGS__)
 
 NAMESPACE_END(pybind11)
 
@@ -1213,6 +1274,6 @@ NAMESPACE_END(pybind11)
 #  pragma warning(pop)
 #elif defined(__ICC) || defined(__INTEL_COMPILER)
 #  pragma warning(pop)
-#elif defined(__GNUG__) and !defined(__clang__)
+#elif defined(__GNUG__) && !defined(__clang__)
 #  pragma GCC diagnostic pop
 #endif
diff --git a/include/pybind11/pytypes.h b/include/pybind11/pytypes.h
index 5a512fa..ad9029b 100644
--- a/include/pybind11/pytypes.h
+++ b/include/pybind11/pytypes.h
@@ -16,12 +16,8 @@
 NAMESPACE_BEGIN(pybind11)
 
 /* A few forward declarations */
-class object;
-class str;
-class object;
-class dict;
-class iterator;
-namespace detail { class accessor; }
+class object; class str; class object; class dict; class iterator;
+namespace detail { class accessor; class args_proxy; class kwargs_proxy; }
 
 /// Holds a reference to a Python object (no reference counting)
 class handle {
@@ -43,11 +39,17 @@ public:
     inline detail::accessor attr(const char *key) const;
     inline pybind11::str str() const;
     template <typename T> T cast() const;
-    template <typename ... Args> object call(Args&&... args_) const;
+    template <typename ... Args>
+    [[deprecated("call(...) was deprecated in favor of operator()(...)")]]
+    object call(Args&&... args) const;
+    template <typename ... Args> object operator()(Args&&... args) const;
+    inline object operator()(detail::args_proxy args) const;
+    inline object operator()(detail::args_proxy f_args, detail::kwargs_proxy kwargs) const;
     operator bool() const { return m_ptr != nullptr; }
     bool operator==(const handle &h) const { return m_ptr == h.m_ptr; }
     bool operator!=(const handle &h) const { return m_ptr != h.m_ptr; }
     bool check() const { return m_ptr != nullptr; }
+    inline detail::args_proxy operator*() const;
 protected:
     PyObject *m_ptr;
 };
@@ -126,7 +128,7 @@ public:
         return result;
     }
 
-    template <typename T> inline T cast() const { return operator object().cast<T>(); }
+    template <typename T> T cast() const { return operator object().cast<T>(); }
 
     operator bool() const {
         if (attr) {
@@ -163,7 +165,7 @@ public:
         return object(result, true);
     }
 
-    template <typename T> inline T cast() const { return operator object().cast<T>(); }
+    template <typename T> T cast() const { return operator object().cast<T>(); }
 private:
     handle list;
     size_t index;
@@ -188,7 +190,7 @@ public:
         return object(result, true);
     }
 
-    template <typename T> inline T cast() const { return operator object().cast<T>(); }
+    template <typename T> T cast() const { return operator object().cast<T>(); }
 private:
     handle tuple;
     size_t index;
@@ -222,18 +224,32 @@ inline bool PyIterable_Check(PyObject *obj) {
         return false;
     }
 }
-    
+
 inline bool PyNone_Check(PyObject *o) { return o == Py_None; }
 
+inline bool PyUnicode_Check_Permissive(PyObject *o) { return PyUnicode_Check(o) || PYBIND11_BYTES_CHECK(o); }
+
+class kwargs_proxy : public handle {
+public:
+    kwargs_proxy(handle h) : handle(h) { }
+};
+
+class args_proxy : public handle {
+public:
+    args_proxy(handle h) : handle(h) { }
+    kwargs_proxy operator*() const { return kwargs_proxy(*this); }
+};
+
 NAMESPACE_END(detail)
 
 #define PYBIND11_OBJECT_CVT(Name, Parent, CheckFun, CvtStmt) \
-    Name(const handle &h, bool borrowed) : Parent(h, borrowed) { CvtStmt; } \
-    Name(const object& o): Parent(o) { CvtStmt; } \
-    Name(object&& o) noexcept : Parent(std::move(o)) { CvtStmt; } \
-    Name& operator=(object&& o) noexcept { (void) object::operator=(std::move(o)); CvtStmt; return *this; } \
-    Name& operator=(const object& o) { return static_cast<Name&>(object::operator=(o)); CvtStmt; } \
-    bool check() const { return m_ptr != nullptr && (bool) CheckFun(m_ptr); }
+    public: \
+        Name(const handle &h, bool borrowed) : Parent(h, borrowed) { CvtStmt; } \
+        Name(const object& o): Parent(o) { CvtStmt; } \
+        Name(object&& o) noexcept : Parent(std::move(o)) { CvtStmt; } \
+        Name& operator=(object&& o) noexcept { (void) object::operator=(std::move(o)); CvtStmt; return *this; } \
+        Name& operator=(const object& o) { return static_cast<Name&>(object::operator=(o)); CvtStmt; } \
+        bool check() const { return m_ptr != nullptr && (bool) CheckFun(m_ptr); }
 
 #define PYBIND11_OBJECT(Name, Parent, CheckFun) \
     PYBIND11_OBJECT_CVT(Name, Parent, CheckFun, )
@@ -307,30 +323,36 @@ public:
     PYBIND11_OBJECT_DEFAULT(iterable, object, detail::PyIterable_Check)
 };
 
-inline detail::accessor handle::operator[](handle key) const { return detail::accessor(ptr(), key.ptr(), false); }
-inline detail::accessor handle::operator[](const char *key) const { return detail::accessor(ptr(), key, false); }
-inline detail::accessor handle::attr(handle key) const { return detail::accessor(ptr(), key.ptr(), true); }
-inline detail::accessor handle::attr(const char *key) const { return detail::accessor(ptr(), key, true); }
+inline detail::accessor handle::operator[](handle key) const { return detail::accessor(*this, key, false); }
+inline detail::accessor handle::operator[](const char *key) const { return detail::accessor(*this, key, false); }
+inline detail::accessor handle::attr(handle key) const { return detail::accessor(*this, key, true); }
+inline detail::accessor handle::attr(const char *key) const { return detail::accessor(*this, key, true); }
 inline iterator handle::begin() const { return iterator(PyObject_GetIter(ptr()), false); }
 inline iterator handle::end() const { return iterator(nullptr, false); }
+inline detail::args_proxy handle::operator*() const { return detail::args_proxy(*this); }
 
 class str : public object {
 public:
-    PYBIND11_OBJECT_DEFAULT(str, object, PyUnicode_Check)
+    PYBIND11_OBJECT_DEFAULT(str, object, detail::PyUnicode_Check_Permissive)
+
     str(const std::string &s)
-        : object(PyUnicode_FromStringAndSize(s.c_str(), s.length()), false) {
+        : object(PyUnicode_FromStringAndSize(s.c_str(), (ssize_t) s.length()), false) {
         if (!m_ptr) pybind11_fail("Could not allocate string object!");
     }
 
     operator std::string() const {
-#if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 3
-        return PyUnicode_AsUTF8(m_ptr);
-#else
-        object temp(PyUnicode_AsUTF8String(m_ptr), false);
-        if (temp.ptr() == nullptr)
-            pybind11_fail("Unable to extract string contents!");
-        return PYBIND11_BYTES_AS_STRING(temp.ptr());
-#endif
+        object temp = *this;
+        if (PyUnicode_Check(m_ptr)) {
+            temp = object(PyUnicode_AsUTF8String(m_ptr), false);
+            if (!temp)
+                pybind11_fail("Unable to extract string contents! (encoding issue)");
+        }
+        char *buffer;
+        ssize_t length;
+        int err = PYBIND11_BYTES_AS_STRING_AND_SIZE(temp.ptr(), &buffer, &length);
+        if (err == -1)
+            pybind11_fail("Unable to extract string contents! (invalid type)");
+        return std::string(buffer, (size_t) length);
     }
 };
 
@@ -348,7 +370,7 @@ public:
     PYBIND11_OBJECT_DEFAULT(bytes, object, PYBIND11_BYTES_CHECK)
 
     bytes(const std::string &s)
-        : object(PYBIND11_BYTES_FROM_STRING_AND_SIZE(s.data(), s.size()), false) {
+        : object(PYBIND11_BYTES_FROM_STRING_AND_SIZE(s.data(), (ssize_t) s.size()), false) {
         if (!m_ptr) pybind11_fail("Could not allocate bytes object!");
     }
 
@@ -358,7 +380,7 @@ public:
         int err = PYBIND11_BYTES_AS_STRING_AND_SIZE(m_ptr, &buffer, &length);
         if (err == -1)
             pybind11_fail("Unable to extract bytes contents!");
-        return std::string(buffer, length);
+        return std::string(buffer, (size_t) length);
     }
 };
 
@@ -441,9 +463,12 @@ public:
         m_ptr = PySlice_New(start.ptr(), stop.ptr(), step.ptr());
         if (!m_ptr) pybind11_fail("Could not allocate slice object!");
     }
-    bool compute(ssize_t length, ssize_t *start, ssize_t *stop, ssize_t *step, ssize_t *slicelength) const {
-        return PySlice_GetIndicesEx((PYBIND11_SLICE_OBJECT *) m_ptr, length,
-                                    start, stop, step, slicelength) == 0;
+    bool compute(size_t length, size_t *start, size_t *stop, size_t *step,
+                 size_t *slicelength) const {
+        return PySlice_GetIndicesEx((PYBIND11_SLICE_OBJECT *) m_ptr,
+                                    (ssize_t) length, (ssize_t *) start,
+                                    (ssize_t *) stop, (ssize_t *) step,
+                                    (ssize_t *) slicelength) == 0;
     }
 };
 
@@ -469,7 +494,7 @@ public:
         if (!m_ptr) pybind11_fail("Could not allocate tuple object!");
     }
     size_t size() const { return (size_t) PyTuple_Size(m_ptr); }
-    detail::tuple_accessor operator[](size_t index) const { return detail::tuple_accessor(ptr(), index); }
+    detail::tuple_accessor operator[](size_t index) const { return detail::tuple_accessor(*this, index); }
 };
 
 class dict : public object {
@@ -479,7 +504,7 @@ public:
         if (!m_ptr) pybind11_fail("Could not allocate dict object!");
     }
     size_t size() const { return (size_t) PyDict_Size(m_ptr); }
-    detail::dict_iterator begin() const { return (++detail::dict_iterator(ptr(), 0)); }
+    detail::dict_iterator begin() const { return (++detail::dict_iterator(*this, 0)); }
     detail::dict_iterator end() const { return detail::dict_iterator(); }
     void clear() const { PyDict_Clear(ptr()); }
 };
@@ -495,6 +520,9 @@ public:
     void append(const object &object) const { PyList_Append(m_ptr, object.ptr()); }
 };
 
+class args : public tuple { PYBIND11_OBJECT_DEFAULT(args, tuple, PyTuple_Check) };
+class kwargs : public dict { PYBIND11_OBJECT_DEFAULT(kwargs, dict, PyDict_Check)  };
+
 class set : public object {
 public:
     PYBIND11_OBJECT(set, object, PySet_Check)
diff --git a/include/pybind11/stl.h b/include/pybind11/stl.h
index 39adc7e..e0177de 100644
--- a/include/pybind11/stl.h
+++ b/include/pybind11/stl.h
@@ -1,5 +1,5 @@
 /*
-    pybind11/complex.h: Complex number support
+    pybind11/stl.h: Transparent conversion for STL data types
 
     Copyright (c) 2016 Wenzel Jakob <wenzel.jakob@epfl.ch>
 
diff --git a/include/pybind11/stl_bind.h b/include/pybind11/stl_bind.h
new file mode 100644
index 0000000..a67f3ca
--- /dev/null
+++ b/include/pybind11/stl_bind.h
@@ -0,0 +1,353 @@
+/*
+    pybind11/std_bind.h: Binding generators for STL data types
+
+    Copyright (c) 2016 Sergey Lyskov and Wenzel Jakob
+
+    All rights reserved. Use of this source code is governed by a
+    BSD-style license that can be found in the LICENSE file.
+*/
+
+#pragma once
+
+#include "common.h"
+#include "operators.h"
+
+#include <type_traits>
+#include <utility>
+#include <algorithm>
+#include <sstream>
+
+NAMESPACE_BEGIN(pybind11)
+NAMESPACE_BEGIN(detail)
+
+/* SFINAE helper class used by 'is_comparable */
+template <typename T>  struct container_traits {
+    template <typename T2> static std::true_type test_comparable(decltype(std::declval<const T2 &>() == std::declval<const T2 &>())*);
+    template <typename T2> static std::false_type test_comparable(...);
+    template <typename T2> static std::true_type test_value(typename T2::value_type *);
+    template <typename T2> static std::false_type test_value(...);
+    template <typename T2> static std::true_type test_pair(typename T2::first_type *, typename T2::second_type *);
+    template <typename T2> static std::false_type test_pair(...);
+
+    static constexpr const bool is_comparable = std::is_same<std::true_type, decltype(test_comparable<T>(nullptr))>::value;
+    static constexpr const bool is_pair = std::is_same<std::true_type, decltype(test_pair<T>(nullptr, nullptr))>::value;
+    static constexpr const bool is_vector = std::is_same<std::true_type, decltype(test_value<T>(nullptr))>::value;
+    static constexpr const bool is_element = !is_pair && !is_vector;
+};
+
+/* Default: is_comparable -> std::false_type */
+template <typename T, typename SFINAE = void>
+struct is_comparable : std::false_type { };
+
+/* For non-map data structures, check whether operator== can be instantiated */
+template <typename T>
+struct is_comparable<
+    T, typename std::enable_if<container_traits<T>::is_element &&
+                               container_traits<T>::is_comparable>::type>
+    : std::true_type { };
+
+/* For a vector/map data structure, recursively check the value type (which is std::pair for maps) */
+template <typename T>
+struct is_comparable<T, typename std::enable_if<container_traits<T>::is_vector>::type> {
+    static constexpr const bool value =
+        is_comparable<typename T::value_type>::value;
+};
+
+/* For pairs, recursively check the two data types */
+template <typename T>
+struct is_comparable<T, typename std::enable_if<container_traits<T>::is_pair>::type> {
+    static constexpr const bool value =
+        is_comparable<typename T::first_type>::value &&
+        is_comparable<typename T::second_type>::value;
+};
+
+/* Fallback functions */
+template <typename, typename, typename... Args> void vector_if_copy_constructible(const Args&...) { }
+template <typename, typename, typename... Args> void vector_if_equal_operator(const Args&...) { }
+template <typename, typename, typename... Args> void vector_if_insertion_operator(const Args&...) { }
+
+template<typename Vector, typename Class_, typename std::enable_if<std::is_copy_constructible<typename Vector::value_type>::value, int>::type = 0>
+void vector_if_copy_constructible(Class_ &cl) {
+    cl.def(pybind11::init<const Vector &>(),
+           "Copy constructor");
+}
+
+template<typename Vector, typename Class_, typename std::enable_if<is_comparable<Vector>::value, int>::type = 0>
+void vector_if_equal_operator(Class_ &cl) {
+    using T = typename Vector::value_type;
+
+    cl.def(self == self);
+    cl.def(self != self);
+
+    cl.def("count",
+        [](const Vector &v, const T &x) {
+            return std::count(v.begin(), v.end(), x);
+        },
+        arg("x"),
+        "Return the number of times ``x`` appears in the list"
+    );
+
+    cl.def("remove", [](Vector &v, const T &x) {
+            auto p = std::find(v.begin(), v.end(), x);
+            if (p != v.end())
+                v.erase(p);
+            else
+                throw pybind11::value_error();
+        },
+        arg("x"),
+        "Remove the first item from the list whose value is x. "
+        "It is an error if there is no such item."
+    );
+
+    cl.def("__contains__",
+        [](const Vector &v, const T &x) {
+            return std::find(v.begin(), v.end(), x) != v.end();
+        },
+        arg("x"),
+        "Return true the container contains ``x``"
+    );
+}
+
+template <typename Vector, typename Class_> auto vector_if_insertion_operator(Class_ &cl, std::string const &name)
+    -> decltype(std::declval<std::ostream&>() << std::declval<typename Vector::value_type>(), void()) {
+    using size_type = typename Vector::size_type;
+
+    cl.def("__repr__",
+           [name](Vector &v) {
+            std::ostringstream s;
+            s << name << '[';
+            for (size_type i=0; i < v.size(); ++i) {
+                s << v[i];
+                if (i != v.size() - 1)
+                    s << ", ";
+            }
+            s << ']';
+            return s.str();
+        },
+        "Return the canonical string representation of this list."
+    );
+}
+
+NAMESPACE_END(detail)
+
+
+template <typename T, typename Allocator = std::allocator<T>, typename holder_type = std::unique_ptr<std::vector<T, Allocator>>, typename... Args>
+pybind11::class_<std::vector<T, Allocator>, holder_type> bind_vector(pybind11::module &m, std::string const &name, Args&&... args) {
+    using Vector = std::vector<T, Allocator>;
+    using SizeType = typename Vector::size_type;
+    using DiffType = typename Vector::difference_type;
+    using ItType   = typename Vector::iterator;
+    using Class_ = pybind11::class_<Vector, holder_type>;
+
+    Class_ cl(m, name.c_str(), std::forward<Args>(args)...);
+
+    cl.def(pybind11::init<>());
+
+    // Register copy constructor (if possible)
+    detail::vector_if_copy_constructible<Vector, Class_>(cl);
+
+    // Register comparison-related operators and functions (if possible)
+    detail::vector_if_equal_operator<Vector, Class_>(cl);
+
+    // Register stream insertion operator (if possible)
+    detail::vector_if_insertion_operator<Vector, Class_>(cl, name);
+
+    cl.def("__init__", [](Vector &v, iterable it) {
+        new (&v) Vector();
+        try {
+            v.reserve(len(it));
+            for (handle h : it)
+               v.push_back(h.cast<typename Vector::value_type>());
+        } catch (...) {
+            v.~Vector();
+            throw;
+        }
+    });
+
+    cl.def("append",
+           [](Vector &v, const T &value) { v.push_back(value); },
+           arg("x"),
+           "Add an item to the end of the list");
+
+    cl.def("extend",
+       [](Vector &v, Vector &src) {
+           v.reserve(v.size() + src.size());
+           v.insert(v.end(), src.begin(), src.end());
+       },
+       arg("L"),
+       "Extend the list by appending all the items in the given list"
+    );
+
+    cl.def("insert",
+        [](Vector &v, SizeType i, const T &x) {
+            v.insert(v.begin() + (DiffType) i, x);
+        },
+        arg("i") , arg("x"),
+        "Insert an item at a given position."
+    );
+
+    cl.def("pop",
+        [](Vector &v) {
+            if (v.empty())
+                throw pybind11::index_error();
+            T t = v.back();
+            v.pop_back();
+            return t;
+        },
+        "Remove and return the last item"
+    );
+
+    cl.def("pop",
+        [](Vector &v, SizeType i) {
+            if (i >= v.size())
+                throw pybind11::index_error();
+            T t = v[i];
+            v.erase(v.begin() + (DiffType) i);
+            return t;
+        },
+        arg("i"),
+        "Remove and return the item at index ``i``"
+    );
+
+    cl.def("__bool__",
+        [](const Vector &v) -> bool {
+            return !v.empty();
+        },
+        "Check whether the list is nonempty"
+    );
+
+    cl.def("__getitem__",
+        [](const Vector &v, SizeType i) -> T {
+            if (i >= v.size())
+                throw pybind11::index_error();
+            return v[i];
+        }
+    );
+
+    cl.def("__setitem__",
+        [](Vector &v, SizeType i, const T &t) {
+            if (i >= v.size())
+                throw pybind11::index_error();
+            v[i] = t;
+        }
+    );
+
+    cl.def("__delitem__",
+        [](Vector &v, SizeType i) {
+            if (i >= v.size())
+                throw pybind11::index_error();
+            v.erase(v.begin() + typename Vector::difference_type(i));
+        },
+        "Delete list elements using a slice object"
+    );
+
+    cl.def("__len__", &Vector::size);
+
+    cl.def("__iter__",
+        [](Vector &v) {
+            return pybind11::make_iterator<ItType, T>(v.begin(), v.end());
+        },
+        pybind11::keep_alive<0, 1>() /* Essential: keep list alive while iterator exists */
+    );
+
+    /// Slicing protocol
+    cl.def("__getitem__",
+        [](const Vector &v, slice slice) -> Vector * {
+            size_t start, stop, step, slicelength;
+
+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))
+                throw pybind11::error_already_set();
+
+            Vector *seq = new Vector();
+            seq->reserve((size_t) slicelength);
+
+            for (size_t i=0; i<slicelength; ++i) {
+                seq->push_back(v[start]);
+                start += step;
+            }
+            return seq;
+        },
+        arg("s"),
+        "Retrieve list elements using a slice object"
+    );
+
+    cl.def("__setitem__",
+        [](Vector &v, slice slice,  const Vector &value) {
+            size_t start, stop, step, slicelength;
+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))
+                throw pybind11::error_already_set();
+
+            if (slicelength != value.size())
+                throw std::runtime_error("Left and right hand size of slice assignment have different sizes!");
+
+            for (size_t i=0; i<slicelength; ++i) {
+                v[start] = value[i];
+                start += step;
+            }
+        },
+        "Assign list elements using a slice object"
+    );
+
+    cl.def("__delitem__",
+        [](Vector &v, slice slice) {
+            size_t start, stop, step, slicelength;
+
+            if (!slice.compute(v.size(), &start, &stop, &step, &slicelength))
+                throw pybind11::error_already_set();
+
+            if (step == 1 && false) {
+                v.erase(v.begin() + (DiffType) start, v.begin() + DiffType(start + slicelength));
+            } else {
+                for (size_t i = 0; i < slicelength; ++i) {
+                    v.erase(v.begin() + DiffType(start));
+                    start += step - 1;
+                }
+            }
+        },
+        "Delete list elements using a slice object"
+    );
+
+#if 0
+    // C++ style functions deprecated, leaving it here as an example
+    cl.def(pybind11::init<size_type>());
+
+    cl.def("resize",
+         (void (Vector::*) (size_type count)) & Vector::resize,
+         "changes the number of elements stored");
+
+    cl.def("erase",
+        [](Vector &v, SizeType i) {
+        if (i >= v.size())
+            throw pybind11::index_error();
+        v.erase(v.begin() + i);
+    }, "erases element at index ``i``");
+
+    cl.def("empty",         &Vector::empty,         "checks whether the container is empty");
+    cl.def("size",          &Vector::size,          "returns the number of elements");
+    cl.def("push_back", (void (Vector::*)(const T&)) &Vector::push_back, "adds an element to the end");
+    cl.def("pop_back",                               &Vector::pop_back, "removes the last element");
+
+    cl.def("max_size",      &Vector::max_size,      "returns the maximum possible number of elements");
+    cl.def("reserve",       &Vector::reserve,       "reserves storage");
+    cl.def("capacity",      &Vector::capacity,      "returns the number of elements that can be held in currently allocated storage");
+    cl.def("shrink_to_fit", &Vector::shrink_to_fit, "reduces memory usage by freeing unused memory");
+
+    cl.def("clear", &Vector::clear, "clears the contents");
+    cl.def("swap",   &Vector::swap, "swaps the contents");
+
+    cl.def("front", [](Vector &v) {
+        if (v.size()) return v.front();
+        else throw pybind11::index_error();
+    }, "access the first element");
+
+    cl.def("back", [](Vector &v) {
+        if (v.size()) return v.back();
+        else throw pybind11::index_error();
+    }, "access the last element ");
+
+#endif
+
+    return cl;
+}
+
+NAMESPACE_END(pybind11)
diff --git a/pybind11/_version.py b/pybind11/_version.py
index 1e7ad88..be66f07 100644
--- a/pybind11/_version.py
+++ b/pybind11/_version.py
@@ -1,2 +1,2 @@
-version_info = (1, 7)
+version_info = (1, 9, 'dev0')
 __version__ = '.'.join(map(str, version_info))
diff --git a/setup.py b/setup.py
index 7562860..07465bb 100644
--- a/setup.py
+++ b/setup.py
@@ -20,9 +20,11 @@ setup(
         'include/pybind11/cast.h',
         'include/pybind11/complex.h',
         'include/pybind11/descr.h',
+        'include/pybind11/eigen.h',
         'include/pybind11/numpy.h',
         'include/pybind11/pybind11.h',
         'include/pybind11/stl.h',
+        'include/pybind11/stl_bind.h',
         'include/pybind11/common.h',
         'include/pybind11/functional.h',
         'include/pybind11/operators.h',
diff --git a/tools/FindEigen3.cmake b/tools/FindEigen3.cmake
new file mode 100644
index 0000000..9c546a0
--- /dev/null
+++ b/tools/FindEigen3.cmake
@@ -0,0 +1,81 @@
+# - Try to find Eigen3 lib
+#
+# This module supports requiring a minimum version, e.g. you can do
+#   find_package(Eigen3 3.1.2)
+# to require version 3.1.2 or newer of Eigen3.
+#
+# Once done this will define
+#
+#  EIGEN3_FOUND - system has eigen lib with correct version
+#  EIGEN3_INCLUDE_DIR - the eigen include directory
+#  EIGEN3_VERSION - eigen version
+
+# Copyright (c) 2006, 2007 Montel Laurent, <montel@kde.org>
+# Copyright (c) 2008, 2009 Gael Guennebaud, <g.gael@free.fr>
+# Copyright (c) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>
+# Redistribution and use is allowed according to the terms of the 2-clause BSD license.
+
+if(NOT Eigen3_FIND_VERSION)
+  if(NOT Eigen3_FIND_VERSION_MAJOR)
+    set(Eigen3_FIND_VERSION_MAJOR 2)
+  endif(NOT Eigen3_FIND_VERSION_MAJOR)
+  if(NOT Eigen3_FIND_VERSION_MINOR)
+    set(Eigen3_FIND_VERSION_MINOR 91)
+  endif(NOT Eigen3_FIND_VERSION_MINOR)
+  if(NOT Eigen3_FIND_VERSION_PATCH)
+    set(Eigen3_FIND_VERSION_PATCH 0)
+  endif(NOT Eigen3_FIND_VERSION_PATCH)
+
+  set(Eigen3_FIND_VERSION "${Eigen3_FIND_VERSION_MAJOR}.${Eigen3_FIND_VERSION_MINOR}.${Eigen3_FIND_VERSION_PATCH}")
+endif(NOT Eigen3_FIND_VERSION)
+
+macro(_eigen3_check_version)
+  file(READ "${EIGEN3_INCLUDE_DIR}/Eigen/src/Core/util/Macros.h" _eigen3_version_header)
+
+  string(REGEX MATCH "define[ \t]+EIGEN_WORLD_VERSION[ \t]+([0-9]+)" _eigen3_world_version_match "${_eigen3_version_header}")
+  set(EIGEN3_WORLD_VERSION "${CMAKE_MATCH_1}")
+  string(REGEX MATCH "define[ \t]+EIGEN_MAJOR_VERSION[ \t]+([0-9]+)" _eigen3_major_version_match "${_eigen3_version_header}")
+  set(EIGEN3_MAJOR_VERSION "${CMAKE_MATCH_1}")
+  string(REGEX MATCH "define[ \t]+EIGEN_MINOR_VERSION[ \t]+([0-9]+)" _eigen3_minor_version_match "${_eigen3_version_header}")
+  set(EIGEN3_MINOR_VERSION "${CMAKE_MATCH_1}")
+
+  set(EIGEN3_VERSION ${EIGEN3_WORLD_VERSION}.${EIGEN3_MAJOR_VERSION}.${EIGEN3_MINOR_VERSION})
+  if(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
+    set(EIGEN3_VERSION_OK FALSE)
+  else(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
+    set(EIGEN3_VERSION_OK TRUE)
+  endif(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
+
+  if(NOT EIGEN3_VERSION_OK)
+
+    message(STATUS "Eigen3 version ${EIGEN3_VERSION} found in ${EIGEN3_INCLUDE_DIR}, "
+                   "but at least version ${Eigen3_FIND_VERSION} is required")
+  endif(NOT EIGEN3_VERSION_OK)
+endmacro(_eigen3_check_version)
+
+if (EIGEN3_INCLUDE_DIR)
+
+  # in cache already
+  _eigen3_check_version()
+  set(EIGEN3_FOUND ${EIGEN3_VERSION_OK})
+
+else (EIGEN3_INCLUDE_DIR)
+
+  find_path(EIGEN3_INCLUDE_DIR NAMES signature_of_eigen3_matrix_library
+      PATHS
+      ${CMAKE_INSTALL_PREFIX}/include
+      ${KDE4_INCLUDE_DIR}
+      PATH_SUFFIXES eigen3 eigen
+    )
+
+  if(EIGEN3_INCLUDE_DIR)
+    _eigen3_check_version()
+  endif(EIGEN3_INCLUDE_DIR)
+
+  include(FindPackageHandleStandardArgs)
+  find_package_handle_standard_args(Eigen3 DEFAULT_MSG EIGEN3_INCLUDE_DIR EIGEN3_VERSION_OK)
+
+  mark_as_advanced(EIGEN3_INCLUDE_DIR)
+
+endif(EIGEN3_INCLUDE_DIR)
+
diff --git a/tools/FindPythonLibsNew.cmake b/tools/FindPythonLibsNew.cmake
new file mode 100644
index 0000000..bfc865c
--- /dev/null
+++ b/tools/FindPythonLibsNew.cmake
@@ -0,0 +1,183 @@
+# - Find python libraries
+# This module finds the libraries corresponding to the Python interpeter
+# FindPythonInterp provides.
+# This code sets the following variables:
+#
+#  PYTHONLIBS_FOUND           - have the Python libs been found
+#  PYTHON_PREFIX              - path to the Python installation
+#  PYTHON_LIBRARIES           - path to the python library
+#  PYTHON_INCLUDE_DIRS        - path to where Python.h is found
+#  PYTHON_MODULE_EXTENSION    - lib extension, e.g. '.so' or '.pyd'
+#  PYTHON_MODULE_PREFIX       - lib name prefix: usually an empty string
+#  PYTHON_SITE_PACKAGES       - path to installation site-packages
+#  PYTHON_IS_DEBUG            - whether the Python interpreter is a debug build
+#
+# Thanks to talljimbo for the patch adding the 'LDVERSION' config
+# variable usage.
+
+#=============================================================================
+# Copyright 2001-2009 Kitware, Inc.
+# Copyright 2012 Continuum Analytics, Inc.
+#
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# * Redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer.
+#
+# * Redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution.
+#
+# * Neither the names of Kitware, Inc., the Insight Software Consortium,
+# nor the names of their contributors may be used to endorse or promote
+# products derived from this software without specific prior written
+# permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# # A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#=============================================================================
+
+if(PYTHONLIBS_FOUND)
+    return()
+endif()
+
+# Use the Python interpreter to find the libs.
+if(PythonLibsNew_FIND_REQUIRED)
+    find_package(PythonInterp ${PythonLibsNew_FIND_VERSION} REQUIRED)
+else()
+    find_package(PythonInterp ${PythonLibsNew_FIND_VERSION})
+endif()
+
+if(NOT PYTHONINTERP_FOUND)
+    set(PYTHONLIBS_FOUND FALSE)
+    return()
+endif()
+
+# According to http://stackoverflow.com/questions/646518/python-how-to-detect-debug-interpreter
+# testing whether sys has the gettotalrefcount function is a reliable, cross-platform
+# way to detect a CPython debug interpreter.
+#
+# The library suffix is from the config var LDVERSION sometimes, otherwise
+# VERSION. VERSION will typically be like "2.7" on unix, and "27" on windows.
+execute_process(COMMAND "${PYTHON_EXECUTABLE}" "-c"
+    "from distutils import sysconfig as s;import sys;import struct;
+print('.'.join(str(v) for v in sys.version_info));
+print(sys.prefix);
+print(s.get_python_inc(plat_specific=True));
+print(s.get_python_lib(plat_specific=True));
+print(s.get_config_var('SO'));
+print(hasattr(sys, 'gettotalrefcount')+0);
+print(struct.calcsize('@P'));
+print(s.get_config_var('LDVERSION') or s.get_config_var('VERSION'));
+"
+    RESULT_VARIABLE _PYTHON_SUCCESS
+    OUTPUT_VARIABLE _PYTHON_VALUES
+    ERROR_VARIABLE _PYTHON_ERROR_VALUE
+    OUTPUT_STRIP_TRAILING_WHITESPACE)
+
+if(NOT _PYTHON_SUCCESS MATCHES 0)
+    if(PythonLibsNew_FIND_REQUIRED)
+        message(FATAL_ERROR
+            "Python config failure:\n${_PYTHON_ERROR_VALUE}")
+    endif()
+    set(PYTHONLIBS_FOUND FALSE)
+    return()
+endif()
+
+# Convert the process output into a list
+string(REGEX REPLACE ";" "\\\\;" _PYTHON_VALUES ${_PYTHON_VALUES})
+string(REGEX REPLACE "\n" ";" _PYTHON_VALUES ${_PYTHON_VALUES})
+list(GET _PYTHON_VALUES 0 _PYTHON_VERSION_LIST)
+list(GET _PYTHON_VALUES 1 PYTHON_PREFIX)
+list(GET _PYTHON_VALUES 2 PYTHON_INCLUDE_DIR)
+list(GET _PYTHON_VALUES 3 PYTHON_SITE_PACKAGES)
+list(GET _PYTHON_VALUES 4 PYTHON_MODULE_EXTENSION)
+list(GET _PYTHON_VALUES 5 PYTHON_IS_DEBUG)
+list(GET _PYTHON_VALUES 6 PYTHON_SIZEOF_VOID_P)
+list(GET _PYTHON_VALUES 7 PYTHON_LIBRARY_SUFFIX)
+
+# Make sure the Python has the same pointer-size as the chosen compiler
+# Skip if CMAKE_SIZEOF_VOID_P is not defined
+if(CMAKE_SIZEOF_VOID_P AND (NOT "${PYTHON_SIZEOF_VOID_P}" STREQUAL "${CMAKE_SIZEOF_VOID_P}"))
+    if(PythonLibsNew_FIND_REQUIRED)
+        math(EXPR _PYTHON_BITS "${PYTHON_SIZEOF_VOID_P} * 8")
+        math(EXPR _CMAKE_BITS "${CMAKE_SIZEOF_VOID_P} * 8")
+        message(FATAL_ERROR
+            "Python config failure: Python is ${_PYTHON_BITS}-bit, "
+            "chosen compiler is  ${_CMAKE_BITS}-bit")
+    endif()
+    set(PYTHONLIBS_FOUND FALSE)
+    return()
+endif()
+
+# The built-in FindPython didn't always give the version numbers
+string(REGEX REPLACE "\\." ";" _PYTHON_VERSION_LIST ${_PYTHON_VERSION_LIST})
+list(GET _PYTHON_VERSION_LIST 0 PYTHON_VERSION_MAJOR)
+list(GET _PYTHON_VERSION_LIST 1 PYTHON_VERSION_MINOR)
+list(GET _PYTHON_VERSION_LIST 2 PYTHON_VERSION_PATCH)
+
+# Make sure all directory separators are '/'
+string(REGEX REPLACE "\\\\" "/" PYTHON_PREFIX ${PYTHON_PREFIX})
+string(REGEX REPLACE "\\\\" "/" PYTHON_INCLUDE_DIR ${PYTHON_INCLUDE_DIR})
+string(REGEX REPLACE "\\\\" "/" PYTHON_SITE_PACKAGES ${PYTHON_SITE_PACKAGES})
+
+# TODO: All the nuances of CPython debug builds have not been dealt with/tested.
+if(PYTHON_IS_DEBUG)
+    set(PYTHON_MODULE_EXTENSION "_d${PYTHON_MODULE_EXTENSION}")
+endif()
+
+if(CMAKE_HOST_WIN32)
+    set(PYTHON_LIBRARY
+        "${PYTHON_PREFIX}/libs/Python${PYTHON_LIBRARY_SUFFIX}.lib")
+elseif(APPLE)
+    set(PYTHON_LIBRARY
+        "${PYTHON_PREFIX}/lib/libpython${PYTHON_LIBRARY_SUFFIX}.dylib")
+else()
+    if(${PYTHON_SIZEOF_VOID_P} MATCHES 8)
+        set(_PYTHON_LIBS_SEARCH "${PYTHON_PREFIX}/lib64" "${PYTHON_PREFIX}/lib")
+    else()
+        set(_PYTHON_LIBS_SEARCH "${PYTHON_PREFIX}/lib")
+    endif()
+    #message(STATUS "Searching for Python libs in ${_PYTHON_LIBS_SEARCH}")
+    # Probably this needs to be more involved. It would be nice if the config
+    # information the python interpreter itself gave us were more complete.
+    find_library(PYTHON_LIBRARY
+        NAMES "python${PYTHON_LIBRARY_SUFFIX}"
+        PATHS ${_PYTHON_LIBS_SEARCH}
+        NO_DEFAULT_PATH)
+
+    # If all else fails, just set the name/version and let the linker figure out the path.
+    if(NOT PYTHON_LIBRARY)
+        set(PYTHON_LIBRARY python${PYTHON_LIBRARY_SUFFIX})
+    endif()
+endif()
+
+MARK_AS_ADVANCED(
+  PYTHON_LIBRARY
+  PYTHON_INCLUDE_DIR
+)
+
+# We use PYTHON_INCLUDE_DIR, PYTHON_LIBRARY and PYTHON_DEBUG_LIBRARY for the
+# cache entries because they are meant to specify the location of a single
+# library. We now set the variables listed by the documentation for this
+# module.
+SET(PYTHON_INCLUDE_DIRS "${PYTHON_INCLUDE_DIR}")
+SET(PYTHON_LIBRARIES "${PYTHON_LIBRARY}")
+SET(PYTHON_DEBUG_LIBRARIES "${PYTHON_DEBUG_LIBRARY}")
+
+find_package_message(PYTHON
+    "Found PythonLibs: ${PYTHON_LIBRARY}"
+    "${PYTHON_EXECUTABLE}${PYTHON_VERSION}")
diff --git a/tools/mkdoc.py b/tools/mkdoc.py
index 25fed03..400fb05 100644
--- a/tools/mkdoc.py
+++ b/tools/mkdoc.py
@@ -22,15 +22,19 @@ RECURSE_LIST = [
     CursorKind.NAMESPACE,
     CursorKind.CLASS_DECL,
     CursorKind.STRUCT_DECL,
+    CursorKind.ENUM_DECL,
     CursorKind.CLASS_TEMPLATE
 ]
 
 PRINT_LIST = [
     CursorKind.CLASS_DECL,
     CursorKind.STRUCT_DECL,
+    CursorKind.ENUM_DECL,
+    CursorKind.ENUM_CONSTANT_DECL,
     CursorKind.CLASS_TEMPLATE,
     CursorKind.FUNCTION_DECL,
     CursorKind.FUNCTION_TEMPLATE,
+    CursorKind.CONVERSION_FUNCTION,
     CursorKind.CXX_METHOD,
     CursorKind.CONSTRUCTOR,
     CursorKind.FIELD_DECL
@@ -43,7 +47,7 @@ CPP_OPERATORS = {
     '>>=': 'irshift', '++': 'inc', '--': 'dec', '<<': 'lshift', '>>':
     'rshift', '&&': 'land', '||': 'lor', '!': 'lnot', '~': 'bnot',
     '&': 'band', '|': 'bor', '+': 'add', '-': 'sub', '*': 'mul', '/':
-    'div', '%': 'mod', '<': 'lt', '>': 'gt', '=': 'assign'
+    'div', '%': 'mod', '<': 'lt', '>': 'gt', '=': 'assign', '()': 'call'
 }
 
 CPP_OPERATORS = OrderedDict(
@@ -61,6 +65,7 @@ def d(s):
 
 def sanitize_name(name):
     global registered_names
+    name = re.sub(r'type-parameter-0-([0-9]+)', r'T\1', name)
     for k, v in CPP_OPERATORS.items():
         name = name.replace('operator%s' % k, 'operator_%s' % v)
     name = re.sub('<.*>', '', name)
@@ -78,17 +83,26 @@ def process_comment(comment):
     result = ''
 
     # Remove C++ comment syntax
-    for s in comment.splitlines():
+    leading_spaces = float('inf')
+    for s in comment.expandtabs(tabsize=4).splitlines():
         s = s.strip()
         if s.startswith('/*'):
-            s = s[2:].lstrip('* \t')
+            s = s[2:].lstrip('*')
         elif s.endswith('*/'):
-            s = s[:-2].rstrip('* \t')
+            s = s[:-2].rstrip('*')
         elif s.startswith('///'):
             s = s[3:]
         if s.startswith('*'):
             s = s[1:]
-        result += s.strip() + '\n'
+        if len(s) > 0:
+            leading_spaces = min(leading_spaces, len(s) - len(s.lstrip()))
+        result += s + '\n'
+
+    if leading_spaces != float('inf'):
+        result2 = ""
+        for s in result.splitlines():
+            result2 += s[leading_spaces:] + '\n'
+        result = result2
 
     # Doxygen tags
     cpp_group = '([\w:]+)'
@@ -100,8 +114,11 @@ def process_comment(comment):
     s = re.sub(r'\\e\s+%s' % cpp_group, r'*\1*', s)
     s = re.sub(r'\\em\s+%s' % cpp_group, r'*\1*', s)
     s = re.sub(r'\\b\s+%s' % cpp_group, r'**\1**', s)
+    s = re.sub(r'\\ingroup\s+%s' % cpp_group, r'', s)
     s = re.sub(r'\\param%s?\s+%s' % (param_group, cpp_group),
                r'\n\n$Parameter ``\2``:\n\n', s)
+    s = re.sub(r'\\tparam%s?\s+%s' % (param_group, cpp_group),
+               r'\n\n$Template parameter ``\2``:\n\n', s)
 
     for in_, out_ in {
         'return': 'Returns',
@@ -123,11 +140,18 @@ def process_comment(comment):
     s = re.sub(r'\\short\s*', r'', s)
     s = re.sub(r'\\ref\s*', r'', s)
 
+    s = re.sub(r'\\code\s?(.*?)\s?\\endcode',
+               r"```\n\1\n```\n", s, flags=re.DOTALL)
+
     # HTML/TeX tags
-    s = re.sub(r'<tt>([^<]*)</tt>', r'``\1``', s)
-    s = re.sub(r'<em>([^<]*)</em>', r'*\1*', s)
-    s = re.sub(r'<b>([^<]*)</b>', r'**\1**', s)
-    s = re.sub(r'\\f\$([^\$]*)\\f\$', r'$\1$', s)
+    s = re.sub(r'<tt>(.*?)</tt>', r'``\1``', s, flags=re.DOTALL)
+    s = re.sub(r'<pre>(.*?)</pre>', r"```\n\1\n```\n", s, flags=re.DOTALL)
+    s = re.sub(r'<em>(.*?)</em>', r'*\1*', s, flags=re.DOTALL)
+    s = re.sub(r'<b>(.*?)</b>', r'**\1**', s, flags=re.DOTALL)
+    s = re.sub(r'\\f\$(.*?)\\f\$', r'$\1$', s, flags=re.DOTALL)
+    s = re.sub(r'<li>', r'\n\n* ', s)
+    s = re.sub(r'</?ul>', r'', s)
+    s = re.sub(r'</li>', r'\n\n', s)
 
     s = s.replace('``true``', '``True``')
     s = s.replace('``false``', '``False``')
@@ -136,19 +160,33 @@ def process_comment(comment):
     wrapper = textwrap.TextWrapper()
     wrapper.expand_tabs = True
     wrapper.replace_whitespace = True
-    wrapper.width = 75
+    wrapper.drop_whitespace = True
+    wrapper.width = 70
     wrapper.initial_indent = wrapper.subsequent_indent = ''
 
     result = ''
-    for x in re.split(r'\n{2,}', s):
-        wrapped = wrapper.fill(x.strip())
-        if len(wrapped) > 0 and wrapped[0] == '$':
-            result += wrapped[1:] + '\n'
-            wrapper.initial_indent = wrapper.subsequent_indent = ' ' * 4
+    in_code_segment = False
+    for x in re.split(r'(```)', s):
+        if x == '```':
+            if not in_code_segment:
+                result += '```\n'
+            else:
+                result += '\n```\n\n'
+            in_code_segment = not in_code_segment
+        elif in_code_segment:
+            result += x.strip()
         else:
-            result += wrapped + '\n\n'
-            wrapper.initial_indent = wrapper.subsequent_indent = ''
-    return result.rstrip()
+            for y in re.split(r'(?: *\n *){2,}', x):
+                wrapped = wrapper.fill(re.sub(r'\s+', ' ', y).strip())
+                if len(wrapped) > 0 and wrapped[0] == '$':
+                    result += wrapped[1:] + '\n'
+                    wrapper.initial_indent = \
+                        wrapper.subsequent_indent = ' ' * 4
+                else:
+                    if len(wrapped) > 0:
+                        result += wrapped + '\n\n'
+                    wrapper.initial_indent = wrapper.subsequent_indent = ''
+    return result.rstrip().lstrip('\n')
 
 
 def extract(filename, node, prefix, output):
@@ -172,10 +210,11 @@ def extract(filename, node, prefix, output):
         sub_prefix = prefix
         if len(sub_prefix) > 0:
             sub_prefix += '_'
-        name = sanitize_name(sub_prefix + d(node.spelling))
-        output.append('\nstatic const char *%s =%sR"doc(%s)doc";' %
-            (name, '\n' if '\n' in comment else ' ', comment))
-        num_extracted += 1
+        if len(node.spelling) > 0:
+            name = sanitize_name(sub_prefix + d(node.spelling))
+            output.append('\nstatic const char *%s =%sR"doc(%s)doc";' %
+                (name, '\n' if '\n' in comment else ' ', comment))
+            num_extracted += 1
     return num_extracted
 
 
@@ -230,19 +269,19 @@ if __name__ == '__main__':
   Do not edit! These were automatically extracted by mkdoc.py
  */
 
-#define __EXPAND(x)                              x
-#define __COUNT(_1, _2, _3, _4, _5, COUNT, ...)  COUNT
-#define __VA_SIZE(...)                           __EXPAND(__COUNT(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1))
-#define __CAT1(a, b)                             a ## b
-#define __CAT2(a, b)                             __CAT1(a, b)
-#define __DOC1(n1)                               __doc_##n1
-#define __DOC2(n1, n2)                           __doc_##n1##_##n2
-#define __DOC3(n1, n2, n3)                       __doc_##n1##_##n2##_##n3
-#define __DOC4(n1, n2, n3, n4)                   __doc_##n1##_##n2##_##n3##_##n4
-#define __DOC5(n1, n2, n3, n4, n5)               __doc_##n1##_##n2##_##n3##_##n4##_##n5
-#define __DOC6(n1, n2, n3, n4, n5, n6)           __doc_##n1##_##n2##_##n3##_##n4##_##n5##_##n6
-#define __DOC7(n1, n2, n3, n4, n5, n6, n7)       __doc_##n1##_##n2##_##n3##_##n4##_##n5##_##n6##_##n7
-#define DOC(...)                                 __EXPAND(__EXPAND(__CAT2(__DOC, __VA_SIZE(__VA_ARGS__)))(__VA_ARGS__))
+#define __EXPAND(x)                                      x
+#define __COUNT(_1, _2, _3, _4, _5, _6, _7, COUNT, ...)  COUNT
+#define __VA_SIZE(...)                                   __EXPAND(__COUNT(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1))
+#define __CAT1(a, b)                                     a ## b
+#define __CAT2(a, b)                                     __CAT1(a, b)
+#define __DOC1(n1)                                       __doc_##n1
+#define __DOC2(n1, n2)                                   __doc_##n1##_##n2
+#define __DOC3(n1, n2, n3)                               __doc_##n1##_##n2##_##n3
+#define __DOC4(n1, n2, n3, n4)                           __doc_##n1##_##n2##_##n3##_##n4
+#define __DOC5(n1, n2, n3, n4, n5)                       __doc_##n1##_##n2##_##n3##_##n4##_##n5
+#define __DOC6(n1, n2, n3, n4, n5, n6)                   __doc_##n1##_##n2##_##n3##_##n4##_##n5##_##n6
+#define __DOC7(n1, n2, n3, n4, n5, n6, n7)               __doc_##n1##_##n2##_##n3##_##n4##_##n5##_##n6##_##n7
+#define DOC(...)                                         __EXPAND(__EXPAND(__CAT2(__DOC, __VA_SIZE(__VA_ARGS__)))(__VA_ARGS__))
 
 #if defined(__GNUG__)
 #pragma GCC diagnostic push
